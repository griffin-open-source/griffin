/* tslint:disable */
/* eslint-disable */
/**
 * griffin-runner API
 * API for managing and running test plans
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AgentsGet200Response {
    'data': Array<AgentsGet200ResponseDataInner>;
    'total': number;
}
export interface AgentsGet200ResponseDataInner {
    'id': string;
    'location': string;
    'status': AgentsGet200ResponseDataInnerStatusEnum;
    'lastHeartbeat': string;
    'registeredAt': string;
    'metadata'?: { [key: string]: string; };
}

export const AgentsGet200ResponseDataInnerStatusEnum = {
    Online: 'online',
    Offline: 'offline'
} as const;

export type AgentsGet200ResponseDataInnerStatusEnum = typeof AgentsGet200ResponseDataInnerStatusEnum[keyof typeof AgentsGet200ResponseDataInnerStatusEnum];

export interface AgentsIdHeartbeatPost200Response {
    'success': boolean;
}
export interface AgentsIdHeartbeatPost404Response {
    'error': string;
}
export interface AgentsLocationsGet200Response {
    'locations': Array<string>;
}
export interface AgentsRegisterPost200Response {
    'id': string;
    'location': string;
    'status': AgentsRegisterPost200ResponseStatusEnum;
    'lastHeartbeat': string;
    'registeredAt': string;
    'metadata'?: { [key: string]: string; };
}

export const AgentsRegisterPost200ResponseStatusEnum = {
    Online: 'online',
    Offline: 'offline'
} as const;

export type AgentsRegisterPost200ResponseStatusEnum = typeof AgentsRegisterPost200ResponseStatusEnum[keyof typeof AgentsRegisterPost200ResponseStatusEnum];

export interface AgentsRegisterPostRequest {
    'location': string;
    'metadata'?: { [key: string]: string; };
}
export interface Assertion {
    'nodeType': AssertionNodeTypeEnum;
    'nodeId': string;
    'accessor': AssertionAccessorEnum;
    'path': string;
    'predicate': AssertionAnyOfAllOfPredicate;
    'expected': any;
}

export const AssertionNodeTypeEnum = {
    Text: 'TEXT'
} as const;

export type AssertionNodeTypeEnum = typeof AssertionNodeTypeEnum[keyof typeof AssertionNodeTypeEnum];
export const AssertionAccessorEnum = {
    Body: 'body',
    Headers: 'headers',
    Status: 'status'
} as const;

export type AssertionAccessorEnum = typeof AssertionAccessorEnum[keyof typeof AssertionAccessorEnum];

export interface AssertionAnyOf {
    'nodeType': AssertionAnyOfNodeTypeEnum;
    'nodeId': string;
    'accessor': AssertionAnyOfAccessorEnum;
    'path': Array<string>;
    'predicate': AssertionAnyOfAllOfPredicate;
}

export const AssertionAnyOfNodeTypeEnum = {
    Json: 'JSON'
} as const;

export type AssertionAnyOfNodeTypeEnum = typeof AssertionAnyOfNodeTypeEnum[keyof typeof AssertionAnyOfNodeTypeEnum];
export const AssertionAnyOfAccessorEnum = {
    Body: 'body',
    Headers: 'headers',
    Status: 'status'
} as const;

export type AssertionAnyOfAccessorEnum = typeof AssertionAnyOfAccessorEnum[keyof typeof AssertionAnyOfAccessorEnum];

export interface AssertionAnyOf1 {
    'nodeType': AssertionAnyOf1NodeTypeEnum;
    'path': Array<string>;
    'expected': any;
}

export const AssertionAnyOf1NodeTypeEnum = {
    Xml: 'XML'
} as const;

export type AssertionAnyOf1NodeTypeEnum = typeof AssertionAnyOf1NodeTypeEnum[keyof typeof AssertionAnyOf1NodeTypeEnum];

export interface AssertionAnyOf2 {
    'nodeType': AssertionAnyOf2NodeTypeEnum;
    'path': string;
    'expected': any;
}

export const AssertionAnyOf2NodeTypeEnum = {
    Text: 'TEXT'
} as const;

export type AssertionAnyOf2NodeTypeEnum = typeof AssertionAnyOf2NodeTypeEnum[keyof typeof AssertionAnyOf2NodeTypeEnum];

export interface AssertionAnyOfAllOfPredicate {
    'expected': any;
    'operator': BinaryPredicateOperator;
}


export interface AssertionAnyOfAllOfPredicateAnyOf {
    'expected': any;
    'operator': BinaryPredicateOperator;
}


export interface Assertions {
    'id': string;
    'type': AssertionsTypeEnum;
    'assertions': Array<Assertion>;
}

export const AssertionsTypeEnum = {
    Assertion: 'ASSERTION'
} as const;

export type AssertionsTypeEnum = typeof AssertionsTypeEnum[keyof typeof AssertionsTypeEnum];

export interface BinaryPredicate {
    'expected': any;
    'operator': BinaryPredicateOperator;
}


export interface BinaryPredicate1 {
    'expected': any;
    'operator': BinaryPredicateOperator;
}



export const BinaryPredicateOperator = {
    Equal: 'EQUAL',
    NotEqual: 'NOT_EQUAL',
    GreaterThan: 'GREATER_THAN',
    LessThan: 'LESS_THAN',
    GreaterThanOrEqual: 'GREATER_THAN_OR_EQUAL',
    LessThanOrEqual: 'LESS_THAN_OR_EQUAL',
    Contains: 'CONTAINS',
    NotContains: 'NOT_CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    NotStartsWith: 'NOT_STARTS_WITH',
    NotEndsWith: 'NOT_ENDS_WITH'
} as const;

export type BinaryPredicateOperator = typeof BinaryPredicateOperator[keyof typeof BinaryPredicateOperator];


export interface ConfigGet200Response {
    'data': Array<ConfigOrganizationIdEnvironmentTargetsTargetKeyPut200ResponseData>;
}
export interface ConfigOrganizationIdEnvironmentTargetsTargetKeyGet200Response {
    'data': ConfigOrganizationIdEnvironmentTargetsTargetKeyGet200ResponseData;
}
export interface ConfigOrganizationIdEnvironmentTargetsTargetKeyGet200ResponseData {
    'baseUrl': string;
}
export interface ConfigOrganizationIdEnvironmentTargetsTargetKeyPut200Response {
    'data': ConfigOrganizationIdEnvironmentTargetsTargetKeyPut200ResponseData;
}
export interface ConfigOrganizationIdEnvironmentTargetsTargetKeyPut200ResponseData {
    'id': string;
    'organizationId': string;
    'environment': string;
    'targets': { [key: string]: string; };
    'createdAt': string;
    'updatedAt': string;
}
export interface ConfigOrganizationIdEnvironmentTargetsTargetKeyPutRequest {
    'baseUrl': string;
}
export interface Edge {
    'from': string;
    'to': string;
}
export interface Endpoint {
    'id': string;
    'type': EndpointTypeEnum;
    'method': HttpMethod;
    'path': string;
    'base': EndpointBase;
    'headers'?: { [key: string]: EndpointHeadersValue; };
    'body'?: any;
    'response_format': ResponseFormat;
}

export const EndpointTypeEnum = {
    Endpoint: 'ENDPOINT'
} as const;

export type EndpointTypeEnum = typeof EndpointTypeEnum[keyof typeof EndpointTypeEnum];

export interface EndpointBase {
    'type': EndpointBaseTypeEnum;
    'key': string;
}

export const EndpointBaseTypeEnum = {
    Target: 'target'
} as const;

export type EndpointBaseTypeEnum = typeof EndpointBaseTypeEnum[keyof typeof EndpointBaseTypeEnum];

export interface EndpointHeadersValue {
    '$secret': EndpointHeadersValueAnyOfSecret;
}
export interface EndpointHeadersValueAnyOf {
    '$secret': EndpointHeadersValueAnyOfSecret;
}
export interface EndpointHeadersValueAnyOfSecret {
    'provider': string;
    'ref': string;
    'version'?: string;
    'field'?: string;
}
export interface Frequency {
    'every': number;
    'unit': FrequencyUnitEnum;
}

export const FrequencyUnitEnum = {
    Minute: 'MINUTE',
    Hour: 'HOUR',
    Day: 'DAY'
} as const;

export type FrequencyUnitEnum = typeof FrequencyUnitEnum[keyof typeof FrequencyUnitEnum];


export const HttpMethod = {
    Get: 'GET',
    Post: 'POST',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD',
    Options: 'OPTIONS',
    Connect: 'CONNECT',
    Trace: 'TRACE'
} as const;

export type HttpMethod = typeof HttpMethod[keyof typeof HttpMethod];


export interface JSONAssertion {
    'nodeId': string;
    'accessor': JSONAssertionAccessorEnum;
    'path': Array<string>;
    'predicate': JSONAssertionPredicate;
}

export const JSONAssertionAccessorEnum = {
    Body: 'body',
    Headers: 'headers',
    Status: 'status'
} as const;

export type JSONAssertionAccessorEnum = typeof JSONAssertionAccessorEnum[keyof typeof JSONAssertionAccessorEnum];

export interface JSONAssertionPredicate {
    'expected': any;
    'operator': BinaryPredicateOperator;
}


/**
 * @type Node
 */
export type Node = Assertions | Endpoint | Wait;

export interface PlanGet200Response {
    'data': Array<TestPlanV1>;
    'total': number;
    'page': number;
    'limit': number;
}
export interface PlanPost201Response {
    'data': TestPlanV1;
}

export const ResponseFormat = {
    Json: 'JSON',
    Xml: 'XML',
    Text: 'TEXT'
} as const;

export type ResponseFormat = typeof ResponseFormat[keyof typeof ResponseFormat];


export interface RunsGet200Response {
    'data': Array<RunsGet200ResponseDataInner>;
    'total': number;
    'page': number;
    'limit': number;
}
export interface RunsGet200ResponseDataInner {
    'id': string;
    'planId': string;
    'executionGroupId': string;
    'location': string;
    'environment': string;
    'status': RunsGet200ResponseDataInnerStatusEnum;
    'triggeredBy': RunsGet200ResponseDataInnerTriggeredByEnum;
    'startedAt': string;
    'completedAt'?: string;
    'duration_ms'?: number;
    'success'?: boolean;
    'errors'?: Array<string>;
}

export const RunsGet200ResponseDataInnerStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type RunsGet200ResponseDataInnerStatusEnum = typeof RunsGet200ResponseDataInnerStatusEnum[keyof typeof RunsGet200ResponseDataInnerStatusEnum];
export const RunsGet200ResponseDataInnerTriggeredByEnum = {
    Schedule: 'schedule',
    Manual: 'manual',
    Api: 'api'
} as const;

export type RunsGet200ResponseDataInnerTriggeredByEnum = typeof RunsGet200ResponseDataInnerTriggeredByEnum[keyof typeof RunsGet200ResponseDataInnerTriggeredByEnum];

export interface RunsIdGet200Response {
    'data': RunsIdGet200ResponseData;
}
export interface RunsIdGet200ResponseData {
    'id': string;
    'planId': string;
    'executionGroupId': string;
    'location': string;
    'environment': string;
    'status': RunsIdGet200ResponseDataStatusEnum;
    'triggeredBy': RunsIdGet200ResponseDataTriggeredByEnum;
    'startedAt': string;
    'completedAt'?: string;
    'duration_ms'?: number;
    'success'?: boolean;
    'errors'?: Array<string>;
}

export const RunsIdGet200ResponseDataStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type RunsIdGet200ResponseDataStatusEnum = typeof RunsIdGet200ResponseDataStatusEnum[keyof typeof RunsIdGet200ResponseDataStatusEnum];
export const RunsIdGet200ResponseDataTriggeredByEnum = {
    Schedule: 'schedule',
    Manual: 'manual',
    Api: 'api'
} as const;

export type RunsIdGet200ResponseDataTriggeredByEnum = typeof RunsIdGet200ResponseDataTriggeredByEnum[keyof typeof RunsIdGet200ResponseDataTriggeredByEnum];

export interface RunsIdPatchRequest {
    'status'?: RunsIdPatchRequestStatusEnum;
    'completedAt'?: string;
    'duration_ms'?: number;
    'success'?: boolean;
    'errors'?: Array<string>;
}

export const RunsIdPatchRequestStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type RunsIdPatchRequestStatusEnum = typeof RunsIdPatchRequestStatusEnum[keyof typeof RunsIdPatchRequestStatusEnum];

export interface RunsTriggerPlanIdPostRequest {
    'environment': string;
}
export interface TestPlanV1 {
    'organization'?: string;
    'project'?: string;
    'locations'?: Array<string>;
    'id': string;
    'name': string;
    'version': TestPlanV1VersionEnum;
    'frequency'?: Frequency;
    'environment': string;
    'nodes': Array<Node>;
    'edges': Array<Edge>;
}

export const TestPlanV1VersionEnum = {
    _10: '1.0'
} as const;

export type TestPlanV1VersionEnum = typeof TestPlanV1VersionEnum[keyof typeof TestPlanV1VersionEnum];


export const UnaryPredicate = {
    IsNull: 'IS_NULL',
    IsNotNull: 'IS_NOT_NULL',
    IsTrue: 'IS_TRUE',
    IsFalse: 'IS_FALSE',
    IsEmpty: 'IS_EMPTY',
    IsNotEmpty: 'IS_NOT_EMPTY'
} as const;

export type UnaryPredicate = typeof UnaryPredicate[keyof typeof UnaryPredicate];


export interface Wait {
    'id': string;
    'type': WaitTypeEnum;
    'duration_ms': number;
}

export const WaitTypeEnum = {
    Wait: 'WAIT'
} as const;

export type WaitTypeEnum = typeof WaitTypeEnum[keyof typeof WaitTypeEnum];


/**
 * AgentsApi - axios parameter creator
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all agents with optional filtering
         * @param {string} [location] Filter by location
         * @param {AgentsGetStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsGet: async (location?: string, status?: AgentsGetStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deregister an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsIdDelete', 'id', id)
            const localVarPath = `/agents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record a heartbeat from an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdHeartbeatPost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsIdHeartbeatPost', 'id', id)
            const localVarPath = `/agents/{id}/heartbeat`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all registered locations (with at least one online agent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsLocationsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agents/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new agent with the hub
         * @param {AgentsRegisterPostRequest} agentsRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsRegisterPost: async (agentsRegisterPostRequest: AgentsRegisterPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentsRegisterPostRequest' is not null or undefined
            assertParamExists('agentsRegisterPost', 'agentsRegisterPostRequest', agentsRegisterPostRequest)
            const localVarPath = `/agents/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentsRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all agents with optional filtering
         * @param {string} [location] Filter by location
         * @param {AgentsGetStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsGet(location?: string, status?: AgentsGetStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsGet(location, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deregister an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsIdHeartbeatPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Record a heartbeat from an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsIdHeartbeatPost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsIdHeartbeatPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsIdHeartbeatPost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsIdHeartbeatPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all registered locations (with at least one online agent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsLocationsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsLocationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsLocationsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsLocationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new agent with the hub
         * @param {AgentsRegisterPostRequest} agentsRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsRegisterPost(agentsRegisterPostRequest: AgentsRegisterPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsRegisterPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsRegisterPost(agentsRegisterPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentsApi - factory interface
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentsApiFp(configuration)
    return {
        /**
         * List all agents with optional filtering
         * @param {string} [location] Filter by location
         * @param {AgentsGetStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsGet(location?: string, status?: AgentsGetStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<AgentsGet200Response> {
            return localVarFp.agentsGet(location, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Deregister an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AgentsIdHeartbeatPost200Response> {
            return localVarFp.agentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Record a heartbeat from an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdHeartbeatPost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AgentsIdHeartbeatPost200Response> {
            return localVarFp.agentsIdHeartbeatPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all registered locations (with at least one online agent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsLocationsGet(options?: RawAxiosRequestConfig): AxiosPromise<AgentsLocationsGet200Response> {
            return localVarFp.agentsLocationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new agent with the hub
         * @param {AgentsRegisterPostRequest} agentsRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsRegisterPost(agentsRegisterPostRequest: AgentsRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentsRegisterPost200Response> {
            return localVarFp.agentsRegisterPost(agentsRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 */
export class AgentsApi extends BaseAPI {
    /**
     * List all agents with optional filtering
     * @param {string} [location] Filter by location
     * @param {AgentsGetStatusEnum} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsGet(location?: string, status?: AgentsGetStatusEnum, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsGet(location, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deregister an agent
     * @param {string} id Agent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record a heartbeat from an agent
     * @param {string} id Agent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsIdHeartbeatPost(id: string, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsIdHeartbeatPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all registered locations (with at least one online agent)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsLocationsGet(options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsLocationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new agent with the hub
     * @param {AgentsRegisterPostRequest} agentsRegisterPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsRegisterPost(agentsRegisterPostRequest: AgentsRegisterPostRequest, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsRegisterPost(agentsRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const AgentsGetStatusEnum = {
    Online: 'online',
    Offline: 'offline'
} as const;
export type AgentsGetStatusEnum = typeof AgentsGetStatusEnum[keyof typeof AgentsGetStatusEnum];


/**
 * ConfigApi - axios parameter creator
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [organizationId] 
         * @param {string} [environment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configGet: async (organizationId?: string, environment?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {string} targetKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configOrganizationIdEnvironmentTargetsTargetKeyDelete: async (organizationId: string, environment: string, targetKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyDelete', 'organizationId', organizationId)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyDelete', 'environment', environment)
            // verify required parameter 'targetKey' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyDelete', 'targetKey', targetKey)
            const localVarPath = `/config/{organizationId}/{environment}/targets/{targetKey}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"targetKey"}}`, encodeURIComponent(String(targetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {string} targetKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configOrganizationIdEnvironmentTargetsTargetKeyGet: async (organizationId: string, environment: string, targetKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyGet', 'organizationId', organizationId)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyGet', 'environment', environment)
            // verify required parameter 'targetKey' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyGet', 'targetKey', targetKey)
            const localVarPath = `/config/{organizationId}/{environment}/targets/{targetKey}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"targetKey"}}`, encodeURIComponent(String(targetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {string} targetKey 
         * @param {ConfigOrganizationIdEnvironmentTargetsTargetKeyPutRequest} configOrganizationIdEnvironmentTargetsTargetKeyPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configOrganizationIdEnvironmentTargetsTargetKeyPut: async (organizationId: string, environment: string, targetKey: string, configOrganizationIdEnvironmentTargetsTargetKeyPutRequest: ConfigOrganizationIdEnvironmentTargetsTargetKeyPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyPut', 'organizationId', organizationId)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyPut', 'environment', environment)
            // verify required parameter 'targetKey' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyPut', 'targetKey', targetKey)
            // verify required parameter 'configOrganizationIdEnvironmentTargetsTargetKeyPutRequest' is not null or undefined
            assertParamExists('configOrganizationIdEnvironmentTargetsTargetKeyPut', 'configOrganizationIdEnvironmentTargetsTargetKeyPutRequest', configOrganizationIdEnvironmentTargetsTargetKeyPutRequest)
            const localVarPath = `/config/{organizationId}/{environment}/targets/{targetKey}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"environment"}}`, encodeURIComponent(String(environment)))
                .replace(`{${"targetKey"}}`, encodeURIComponent(String(targetKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configOrganizationIdEnvironmentTargetsTargetKeyPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSingleGet: async (organizationId: string, environment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('configSingleGet', 'organizationId', organizationId)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('configSingleGet', 'environment', environment)
            const localVarPath = `/config/single`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [organizationId] 
         * @param {string} [environment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configGet(organizationId?: string, environment?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configGet(organizationId, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.configGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {string} targetKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configOrganizationIdEnvironmentTargetsTargetKeyDelete(organizationId: string, environment: string, targetKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configOrganizationIdEnvironmentTargetsTargetKeyDelete(organizationId, environment, targetKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.configOrganizationIdEnvironmentTargetsTargetKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {string} targetKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configOrganizationIdEnvironmentTargetsTargetKeyGet(organizationId: string, environment: string, targetKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigOrganizationIdEnvironmentTargetsTargetKeyGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configOrganizationIdEnvironmentTargetsTargetKeyGet(organizationId, environment, targetKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.configOrganizationIdEnvironmentTargetsTargetKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {string} targetKey 
         * @param {ConfigOrganizationIdEnvironmentTargetsTargetKeyPutRequest} configOrganizationIdEnvironmentTargetsTargetKeyPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configOrganizationIdEnvironmentTargetsTargetKeyPut(organizationId: string, environment: string, targetKey: string, configOrganizationIdEnvironmentTargetsTargetKeyPutRequest: ConfigOrganizationIdEnvironmentTargetsTargetKeyPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigOrganizationIdEnvironmentTargetsTargetKeyPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configOrganizationIdEnvironmentTargetsTargetKeyPut(organizationId, environment, targetKey, configOrganizationIdEnvironmentTargetsTargetKeyPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.configOrganizationIdEnvironmentTargetsTargetKeyPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configSingleGet(organizationId: string, environment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigOrganizationIdEnvironmentTargetsTargetKeyPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configSingleGet(organizationId, environment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.configSingleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigApi - factory interface
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [organizationId] 
         * @param {string} [environment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configGet(organizationId?: string, environment?: string, options?: RawAxiosRequestConfig): AxiosPromise<ConfigGet200Response> {
            return localVarFp.configGet(organizationId, environment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {string} targetKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configOrganizationIdEnvironmentTargetsTargetKeyDelete(organizationId: string, environment: string, targetKey: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.configOrganizationIdEnvironmentTargetsTargetKeyDelete(organizationId, environment, targetKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {string} targetKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configOrganizationIdEnvironmentTargetsTargetKeyGet(organizationId: string, environment: string, targetKey: string, options?: RawAxiosRequestConfig): AxiosPromise<ConfigOrganizationIdEnvironmentTargetsTargetKeyGet200Response> {
            return localVarFp.configOrganizationIdEnvironmentTargetsTargetKeyGet(organizationId, environment, targetKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {string} targetKey 
         * @param {ConfigOrganizationIdEnvironmentTargetsTargetKeyPutRequest} configOrganizationIdEnvironmentTargetsTargetKeyPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configOrganizationIdEnvironmentTargetsTargetKeyPut(organizationId: string, environment: string, targetKey: string, configOrganizationIdEnvironmentTargetsTargetKeyPutRequest: ConfigOrganizationIdEnvironmentTargetsTargetKeyPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConfigOrganizationIdEnvironmentTargetsTargetKeyPut200Response> {
            return localVarFp.configOrganizationIdEnvironmentTargetsTargetKeyPut(organizationId, environment, targetKey, configOrganizationIdEnvironmentTargetsTargetKeyPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} environment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configSingleGet(organizationId: string, environment: string, options?: RawAxiosRequestConfig): AxiosPromise<ConfigOrganizationIdEnvironmentTargetsTargetKeyPut200Response> {
            return localVarFp.configSingleGet(organizationId, environment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - object-oriented interface
 */
export class ConfigApi extends BaseAPI {
    /**
     * 
     * @param {string} [organizationId] 
     * @param {string} [environment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configGet(organizationId?: string, environment?: string, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).configGet(organizationId, environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {string} environment 
     * @param {string} targetKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configOrganizationIdEnvironmentTargetsTargetKeyDelete(organizationId: string, environment: string, targetKey: string, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).configOrganizationIdEnvironmentTargetsTargetKeyDelete(organizationId, environment, targetKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {string} environment 
     * @param {string} targetKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configOrganizationIdEnvironmentTargetsTargetKeyGet(organizationId: string, environment: string, targetKey: string, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).configOrganizationIdEnvironmentTargetsTargetKeyGet(organizationId, environment, targetKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {string} environment 
     * @param {string} targetKey 
     * @param {ConfigOrganizationIdEnvironmentTargetsTargetKeyPutRequest} configOrganizationIdEnvironmentTargetsTargetKeyPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configOrganizationIdEnvironmentTargetsTargetKeyPut(organizationId: string, environment: string, targetKey: string, configOrganizationIdEnvironmentTargetsTargetKeyPutRequest: ConfigOrganizationIdEnvironmentTargetsTargetKeyPutRequest, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).configOrganizationIdEnvironmentTargetsTargetKeyPut(organizationId, environment, targetKey, configOrganizationIdEnvironmentTargetsTargetKeyPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {string} environment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public configSingleGet(organizationId: string, environment: string, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).configSingleGet(organizationId, environment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlanApi - axios parameter creator
 */
export const PlanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [projectId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planGet: async (projectId?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TestPlanV1} [testPlanV1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planPost: async (testPlanV1?: TestPlanV1, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testPlanV1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanApi - functional programming interface
 */
export const PlanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlanApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [projectId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async planGet(projectId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.planGet(projectId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanApi.planGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TestPlanV1} [testPlanV1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async planPost(testPlanV1?: TestPlanV1, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.planPost(testPlanV1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanApi.planPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlanApi - factory interface
 */
export const PlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlanApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [projectId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planGet(projectId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PlanGet200Response> {
            return localVarFp.planGet(projectId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TestPlanV1} [testPlanV1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planPost(testPlanV1?: TestPlanV1, options?: RawAxiosRequestConfig): AxiosPromise<PlanPost201Response> {
            return localVarFp.planPost(testPlanV1, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlanApi - object-oriented interface
 */
export class PlanApi extends BaseAPI {
    /**
     * 
     * @param {string} [projectId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public planGet(projectId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return PlanApiFp(this.configuration).planGet(projectId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TestPlanV1} [testPlanV1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public planPost(testPlanV1?: TestPlanV1, options?: RawAxiosRequestConfig) {
        return PlanApiFp(this.configuration).planPost(testPlanV1, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunsApi - axios parameter creator
 */
export const RunsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [planId] 
         * @param {RunsGetStatusEnum} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsGet: async (planId?: string, status?: RunsGetStatusEnum, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/runs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runsIdGet', 'id', id)
            const localVarPath = `/runs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RunsIdPatchRequest} [runsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsIdPatch: async (id: string, runsIdPatchRequest?: RunsIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runsIdPatch', 'id', id)
            const localVarPath = `/runs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} planId 
         * @param {RunsTriggerPlanIdPostRequest} runsTriggerPlanIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsTriggerPlanIdPost: async (planId: string, runsTriggerPlanIdPostRequest: RunsTriggerPlanIdPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('runsTriggerPlanIdPost', 'planId', planId)
            // verify required parameter 'runsTriggerPlanIdPostRequest' is not null or undefined
            assertParamExists('runsTriggerPlanIdPost', 'runsTriggerPlanIdPostRequest', runsTriggerPlanIdPostRequest)
            const localVarPath = `/runs/trigger/{planId}`
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runsTriggerPlanIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsApi - functional programming interface
 */
export const RunsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [planId] 
         * @param {RunsGetStatusEnum} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runsGet(planId?: string, status?: RunsGetStatusEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runsGet(planId, status, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunsApi.runsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunsApi.runsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RunsIdPatchRequest} [runsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runsIdPatch(id: string, runsIdPatchRequest?: RunsIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runsIdPatch(id, runsIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunsApi.runsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} planId 
         * @param {RunsTriggerPlanIdPostRequest} runsTriggerPlanIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runsTriggerPlanIdPost(planId: string, runsTriggerPlanIdPostRequest: RunsTriggerPlanIdPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runsTriggerPlanIdPost(planId, runsTriggerPlanIdPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunsApi.runsTriggerPlanIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunsApi - factory interface
 */
export const RunsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [planId] 
         * @param {RunsGetStatusEnum} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsGet(planId?: string, status?: RunsGetStatusEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<RunsGet200Response> {
            return localVarFp.runsGet(planId, status, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RunsIdGet200Response> {
            return localVarFp.runsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RunsIdPatchRequest} [runsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsIdPatch(id: string, runsIdPatchRequest?: RunsIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunsIdGet200Response> {
            return localVarFp.runsIdPatch(id, runsIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} planId 
         * @param {RunsTriggerPlanIdPostRequest} runsTriggerPlanIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsTriggerPlanIdPost(planId: string, runsTriggerPlanIdPostRequest: RunsTriggerPlanIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunsIdGet200Response> {
            return localVarFp.runsTriggerPlanIdPost(planId, runsTriggerPlanIdPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunsApi - object-oriented interface
 */
export class RunsApi extends BaseAPI {
    /**
     * 
     * @param {string} [planId] 
     * @param {RunsGetStatusEnum} [status] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runsGet(planId?: string, status?: RunsGetStatusEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return RunsApiFp(this.configuration).runsGet(planId, status, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return RunsApiFp(this.configuration).runsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RunsIdPatchRequest} [runsIdPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runsIdPatch(id: string, runsIdPatchRequest?: RunsIdPatchRequest, options?: RawAxiosRequestConfig) {
        return RunsApiFp(this.configuration).runsIdPatch(id, runsIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} planId 
     * @param {RunsTriggerPlanIdPostRequest} runsTriggerPlanIdPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runsTriggerPlanIdPost(planId: string, runsTriggerPlanIdPostRequest: RunsTriggerPlanIdPostRequest, options?: RawAxiosRequestConfig) {
        return RunsApiFp(this.configuration).runsTriggerPlanIdPost(planId, runsTriggerPlanIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const RunsGetStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;
export type RunsGetStatusEnum = typeof RunsGetStatusEnum[keyof typeof RunsGetStatusEnum];


