/* tslint:disable */
/* eslint-disable */
/**
 * griffin-runner API
 * API for managing and running test plans
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AgentsGet200Response {
    'data': Array<AgentsGet200ResponseDataInner>;
    'total': number;
}
export interface AgentsGet200ResponseDataInner {
    'id': string;
    'location': string;
    'status': AgentsGet200ResponseDataInnerStatusEnum;
    'lastHeartbeat': string;
    'registeredAt': string;
    'metadata'?: { [key: string]: string; };
}

export const AgentsGet200ResponseDataInnerStatusEnum = {
    Online: 'online',
    Offline: 'offline'
} as const;

export type AgentsGet200ResponseDataInnerStatusEnum = typeof AgentsGet200ResponseDataInnerStatusEnum[keyof typeof AgentsGet200ResponseDataInnerStatusEnum];

export interface AgentsIdHeartbeatPost200Response {
    'success': boolean;
}
export interface AgentsIdHeartbeatPost404Response {
    'error': string;
}
export interface AgentsLocationsGet200Response {
    'locations': Array<string>;
}
export interface AgentsRegisterPost200Response {
    'id': string;
    'location': string;
    'status': AgentsRegisterPost200ResponseStatusEnum;
    'lastHeartbeat': string;
    'registeredAt': string;
    'metadata'?: { [key: string]: string; };
}

export const AgentsRegisterPost200ResponseStatusEnum = {
    Online: 'online',
    Offline: 'offline'
} as const;

export type AgentsRegisterPost200ResponseStatusEnum = typeof AgentsRegisterPost200ResponseStatusEnum[keyof typeof AgentsRegisterPost200ResponseStatusEnum];

export interface AgentsRegisterPostRequest {
    'location': string;
    'metadata'?: { [key: string]: string; };
}
export interface Assertion {
    'assertionType': AssertionAssertionTypeEnum;
    'nodeId': string;
    'accessor': AssertionAccessorEnum;
    'path': string;
    'predicate': JSONAssertion1Predicate;
    'expected': any;
}

export const AssertionAssertionTypeEnum = {
    Text: 'TEXT'
} as const;

export type AssertionAssertionTypeEnum = typeof AssertionAssertionTypeEnum[keyof typeof AssertionAssertionTypeEnum];
export const AssertionAccessorEnum = {
    Body: 'body',
    Headers: 'headers',
    Status: 'status'
} as const;

export type AssertionAccessorEnum = typeof AssertionAccessorEnum[keyof typeof AssertionAccessorEnum];

export interface Assertion1 {
    'assertionType': Assertion1AssertionTypeEnum;
    'nodeId': string;
    'accessor': Assertion1AccessorEnum;
    'path': string;
    'predicate': JSONAssertion1Predicate;
    'expected': any;
}

export const Assertion1AssertionTypeEnum = {
    Text: 'TEXT'
} as const;

export type Assertion1AssertionTypeEnum = typeof Assertion1AssertionTypeEnum[keyof typeof Assertion1AssertionTypeEnum];
export const Assertion1AccessorEnum = {
    Body: 'body',
    Headers: 'headers',
    Status: 'status'
} as const;

export type Assertion1AccessorEnum = typeof Assertion1AccessorEnum[keyof typeof Assertion1AccessorEnum];

export interface Assertion1AnyOf {
    'assertionType': Assertion1AnyOfAssertionTypeEnum;
    'nodeId': string;
    'accessor': Assertion1AnyOfAccessorEnum;
    'path': Array<string>;
    'predicate': JSONAssertion1Predicate;
}

export const Assertion1AnyOfAssertionTypeEnum = {
    Json: 'JSON'
} as const;

export type Assertion1AnyOfAssertionTypeEnum = typeof Assertion1AnyOfAssertionTypeEnum[keyof typeof Assertion1AnyOfAssertionTypeEnum];
export const Assertion1AnyOfAccessorEnum = {
    Body: 'body',
    Headers: 'headers',
    Status: 'status'
} as const;

export type Assertion1AnyOfAccessorEnum = typeof Assertion1AnyOfAccessorEnum[keyof typeof Assertion1AnyOfAccessorEnum];

export interface Assertions {
    'id': string;
    'type': AssertionsTypeEnum;
    'assertions': Array<Assertion1>;
}

export const AssertionsTypeEnum = {
    Assertion: 'ASSERTION'
} as const;

export type AssertionsTypeEnum = typeof AssertionsTypeEnum[keyof typeof AssertionsTypeEnum];

export interface Assertions1 {
    'id': string;
    'type': Assertions1TypeEnum;
    'assertions': Array<Assertion1>;
}

export const Assertions1TypeEnum = {
    Assertion: 'ASSERTION'
} as const;

export type Assertions1TypeEnum = typeof Assertions1TypeEnum[keyof typeof Assertions1TypeEnum];

export interface BinaryPredicate {
    'expected': any;
    'operator': BinaryPredicateOperatorEnum;
}

export const BinaryPredicateOperatorEnum = {
    Equal: 'EQUAL',
    NotEqual: 'NOT_EQUAL',
    GreaterThan: 'GREATER_THAN',
    LessThan: 'LESS_THAN',
    GreaterThanOrEqual: 'GREATER_THAN_OR_EQUAL',
    LessThanOrEqual: 'LESS_THAN_OR_EQUAL',
    Contains: 'CONTAINS',
    NotContains: 'NOT_CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    NotStartsWith: 'NOT_STARTS_WITH',
    NotEndsWith: 'NOT_ENDS_WITH'
} as const;

export type BinaryPredicateOperatorEnum = typeof BinaryPredicateOperatorEnum[keyof typeof BinaryPredicateOperatorEnum];

export interface BinaryPredicate1 {
    'expected': any;
    'operator': BinaryPredicate1OperatorEnum;
}

export const BinaryPredicate1OperatorEnum = {
    Equal: 'EQUAL',
    NotEqual: 'NOT_EQUAL',
    GreaterThan: 'GREATER_THAN',
    LessThan: 'LESS_THAN',
    GreaterThanOrEqual: 'GREATER_THAN_OR_EQUAL',
    LessThanOrEqual: 'LESS_THAN_OR_EQUAL',
    Contains: 'CONTAINS',
    NotContains: 'NOT_CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    NotStartsWith: 'NOT_STARTS_WITH',
    NotEndsWith: 'NOT_ENDS_WITH'
} as const;

export type BinaryPredicate1OperatorEnum = typeof BinaryPredicate1OperatorEnum[keyof typeof BinaryPredicate1OperatorEnum];


export const BinaryPredicateOperator = {
    Equal: 'EQUAL',
    NotEqual: 'NOT_EQUAL',
    GreaterThan: 'GREATER_THAN',
    LessThan: 'LESS_THAN',
    GreaterThanOrEqual: 'GREATER_THAN_OR_EQUAL',
    LessThanOrEqual: 'LESS_THAN_OR_EQUAL',
    Contains: 'CONTAINS',
    NotContains: 'NOT_CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    NotStartsWith: 'NOT_STARTS_WITH',
    NotEndsWith: 'NOT_ENDS_WITH'
} as const;

export type BinaryPredicateOperator = typeof BinaryPredicateOperator[keyof typeof BinaryPredicateOperator];


export interface Edge {
    'from': string;
    'to': string;
}
export interface Edge1 {
    'from': string;
    'to': string;
}
export interface Endpoint {
    'id': string;
    'type': EndpointTypeEnum;
    'method': EndpointMethodEnum;
    'path': PlanPostRequestNodesInnerAnyOfPath;
    'base': PlanPostRequestNodesInnerAnyOfPath;
    'headers'?: { [key: string]: PlanPostRequestNodesInnerAnyOfHeadersValue; };
    'body'?: any;
    'response_format': EndpointResponseFormatEnum;
}

export const EndpointTypeEnum = {
    Endpoint: 'ENDPOINT'
} as const;

export type EndpointTypeEnum = typeof EndpointTypeEnum[keyof typeof EndpointTypeEnum];
export const EndpointMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD',
    Options: 'OPTIONS',
    Connect: 'CONNECT',
    Trace: 'TRACE'
} as const;

export type EndpointMethodEnum = typeof EndpointMethodEnum[keyof typeof EndpointMethodEnum];
export const EndpointResponseFormatEnum = {
    Json: 'JSON',
    Xml: 'XML',
    Text: 'TEXT'
} as const;

export type EndpointResponseFormatEnum = typeof EndpointResponseFormatEnum[keyof typeof EndpointResponseFormatEnum];

export interface Endpoint1 {
    'id': string;
    'type': Endpoint1TypeEnum;
    'method': Endpoint1MethodEnum;
    'path': PlanPostRequestNodesInnerAnyOfPath;
    'base': PlanPostRequestNodesInnerAnyOfPath;
    'headers'?: { [key: string]: PlanPostRequestNodesInnerAnyOfHeadersValue; };
    'body'?: any;
    'response_format': Endpoint1ResponseFormatEnum;
}

export const Endpoint1TypeEnum = {
    Endpoint: 'ENDPOINT'
} as const;

export type Endpoint1TypeEnum = typeof Endpoint1TypeEnum[keyof typeof Endpoint1TypeEnum];
export const Endpoint1MethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD',
    Options: 'OPTIONS',
    Connect: 'CONNECT',
    Trace: 'TRACE'
} as const;

export type Endpoint1MethodEnum = typeof Endpoint1MethodEnum[keyof typeof Endpoint1MethodEnum];
export const Endpoint1ResponseFormatEnum = {
    Json: 'JSON',
    Xml: 'XML',
    Text: 'TEXT'
} as const;

export type Endpoint1ResponseFormatEnum = typeof Endpoint1ResponseFormatEnum[keyof typeof Endpoint1ResponseFormatEnum];

export interface Frequency {
    'every': number;
    'unit': FrequencyUnitEnum;
}

export const FrequencyUnitEnum = {
    Minute: 'MINUTE',
    Hour: 'HOUR',
    Day: 'DAY'
} as const;

export type FrequencyUnitEnum = typeof FrequencyUnitEnum[keyof typeof FrequencyUnitEnum];

export interface Frequency1 {
    'every': number;
    'unit': Frequency1UnitEnum;
}

export const Frequency1UnitEnum = {
    Minute: 'MINUTE',
    Hour: 'HOUR',
    Day: 'DAY'
} as const;

export type Frequency1UnitEnum = typeof Frequency1UnitEnum[keyof typeof Frequency1UnitEnum];


export const HttpMethod = {
    Get: 'GET',
    Post: 'POST',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD',
    Options: 'OPTIONS',
    Connect: 'CONNECT',
    Trace: 'TRACE'
} as const;

export type HttpMethod = typeof HttpMethod[keyof typeof HttpMethod];


export interface JSONAssertion {
    'nodeId': string;
    'accessor': JSONAssertionAccessorEnum;
    'path': Array<string>;
    'predicate': JSONAssertion1Predicate;
}

export const JSONAssertionAccessorEnum = {
    Body: 'body',
    Headers: 'headers',
    Status: 'status'
} as const;

export type JSONAssertionAccessorEnum = typeof JSONAssertionAccessorEnum[keyof typeof JSONAssertionAccessorEnum];

export interface JSONAssertion1Predicate {
    'expected': any;
    'operator': JSONAssertion1PredicateOperatorEnum;
}

export const JSONAssertion1PredicateOperatorEnum = {
    Equal: 'EQUAL',
    NotEqual: 'NOT_EQUAL',
    GreaterThan: 'GREATER_THAN',
    LessThan: 'LESS_THAN',
    GreaterThanOrEqual: 'GREATER_THAN_OR_EQUAL',
    LessThanOrEqual: 'LESS_THAN_OR_EQUAL',
    Contains: 'CONTAINS',
    NotContains: 'NOT_CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    NotStartsWith: 'NOT_STARTS_WITH',
    NotEndsWith: 'NOT_ENDS_WITH'
} as const;

export type JSONAssertion1PredicateOperatorEnum = typeof JSONAssertion1PredicateOperatorEnum[keyof typeof JSONAssertion1PredicateOperatorEnum];

/**
 * @type Node
 */
export type Node = Assertions1 | Endpoint1 | Wait1;

export interface Node1 {
    'id': string;
    'type': Node1TypeEnum;
    'method': Node1MethodEnum;
    'path': PlanPostRequestNodesInnerAnyOfPath;
    'base': PlanPostRequestNodesInnerAnyOfPath;
    'headers'?: { [key: string]: PlanPostRequestNodesInnerAnyOfHeadersValue; };
    'body'?: any;
    'response_format': Node1ResponseFormatEnum;
    'duration_ms': number;
    'assertions': Array<Assertion1>;
}

export const Node1TypeEnum = {
    Endpoint: 'ENDPOINT',
    Wait: 'WAIT',
    Assertion: 'ASSERTION'
} as const;

export type Node1TypeEnum = typeof Node1TypeEnum[keyof typeof Node1TypeEnum];
export const Node1MethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD',
    Options: 'OPTIONS',
    Connect: 'CONNECT',
    Trace: 'TRACE'
} as const;

export type Node1MethodEnum = typeof Node1MethodEnum[keyof typeof Node1MethodEnum];
export const Node1ResponseFormatEnum = {
    Json: 'JSON',
    Xml: 'XML',
    Text: 'TEXT'
} as const;

export type Node1ResponseFormatEnum = typeof Node1ResponseFormatEnum[keyof typeof Node1ResponseFormatEnum];

export interface PlanGet200Response {
    'data': Array<TestPlanV1>;
    'total': number;
    'page': number;
    'limit': number;
}
export interface PlanPost201Response {
    'data': TestPlanV1;
}
export interface PlanPostRequest {
    'project': string;
    'locations'?: Array<string>;
    'name': string;
    'version': PlanPostRequestVersionEnum;
    'frequency': PlanPostRequestFrequency;
    'environment': string;
    'nodes': Array<PlanPostRequestNodesInner>;
    'edges': Array<PlanPostRequestEdgesInner>;
}

export const PlanPostRequestVersionEnum = {
    _10: '1.0'
} as const;

export type PlanPostRequestVersionEnum = typeof PlanPostRequestVersionEnum[keyof typeof PlanPostRequestVersionEnum];

export interface PlanPostRequestEdgesInner {
    'from': string;
    'to': string;
}
export interface PlanPostRequestFrequency {
    'every': number;
    'unit': PlanPostRequestFrequencyUnitEnum;
}

export const PlanPostRequestFrequencyUnitEnum = {
    Minute: 'MINUTE',
    Hour: 'HOUR',
    Day: 'DAY'
} as const;

export type PlanPostRequestFrequencyUnitEnum = typeof PlanPostRequestFrequencyUnitEnum[keyof typeof PlanPostRequestFrequencyUnitEnum];

export interface PlanPostRequestNodesInner {
    'id': string;
    'type': PlanPostRequestNodesInnerTypeEnum;
    'method': PlanPostRequestNodesInnerMethodEnum;
    'path': PlanPostRequestNodesInnerAnyOfPath;
    'base': PlanPostRequestNodesInnerAnyOfPath;
    'headers'?: { [key: string]: PlanPostRequestNodesInnerAnyOfHeadersValue; };
    'body'?: any;
    'response_format': PlanPostRequestNodesInnerResponseFormatEnum;
    'duration_ms': number;
    'assertions': Array<PlanPostRequestNodesInnerAnyOf2AssertionsInner>;
}

export const PlanPostRequestNodesInnerTypeEnum = {
    Endpoint: 'ENDPOINT',
    Wait: 'WAIT',
    Assertion: 'ASSERTION'
} as const;

export type PlanPostRequestNodesInnerTypeEnum = typeof PlanPostRequestNodesInnerTypeEnum[keyof typeof PlanPostRequestNodesInnerTypeEnum];
export const PlanPostRequestNodesInnerMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD',
    Options: 'OPTIONS',
    Connect: 'CONNECT',
    Trace: 'TRACE'
} as const;

export type PlanPostRequestNodesInnerMethodEnum = typeof PlanPostRequestNodesInnerMethodEnum[keyof typeof PlanPostRequestNodesInnerMethodEnum];
export const PlanPostRequestNodesInnerResponseFormatEnum = {
    Json: 'JSON',
    Xml: 'XML',
    Text: 'TEXT'
} as const;

export type PlanPostRequestNodesInnerResponseFormatEnum = typeof PlanPostRequestNodesInnerResponseFormatEnum[keyof typeof PlanPostRequestNodesInnerResponseFormatEnum];

export interface PlanPostRequestNodesInnerAnyOf {
    'id': string;
    'type': PlanPostRequestNodesInnerAnyOfTypeEnum;
    'method': PlanPostRequestNodesInnerAnyOfMethodEnum;
    'path': PlanPostRequestNodesInnerAnyOfPath;
    'base': PlanPostRequestNodesInnerAnyOfPath;
    'headers'?: { [key: string]: PlanPostRequestNodesInnerAnyOfHeadersValue; };
    'body'?: any;
    'response_format': PlanPostRequestNodesInnerAnyOfResponseFormatEnum;
}

export const PlanPostRequestNodesInnerAnyOfTypeEnum = {
    Endpoint: 'ENDPOINT'
} as const;

export type PlanPostRequestNodesInnerAnyOfTypeEnum = typeof PlanPostRequestNodesInnerAnyOfTypeEnum[keyof typeof PlanPostRequestNodesInnerAnyOfTypeEnum];
export const PlanPostRequestNodesInnerAnyOfMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD',
    Options: 'OPTIONS',
    Connect: 'CONNECT',
    Trace: 'TRACE'
} as const;

export type PlanPostRequestNodesInnerAnyOfMethodEnum = typeof PlanPostRequestNodesInnerAnyOfMethodEnum[keyof typeof PlanPostRequestNodesInnerAnyOfMethodEnum];
export const PlanPostRequestNodesInnerAnyOfResponseFormatEnum = {
    Json: 'JSON',
    Xml: 'XML',
    Text: 'TEXT'
} as const;

export type PlanPostRequestNodesInnerAnyOfResponseFormatEnum = typeof PlanPostRequestNodesInnerAnyOfResponseFormatEnum[keyof typeof PlanPostRequestNodesInnerAnyOfResponseFormatEnum];

export interface PlanPostRequestNodesInnerAnyOf1 {
    'id': string;
    'type': PlanPostRequestNodesInnerAnyOf1TypeEnum;
    'duration_ms': number;
}

export const PlanPostRequestNodesInnerAnyOf1TypeEnum = {
    Wait: 'WAIT'
} as const;

export type PlanPostRequestNodesInnerAnyOf1TypeEnum = typeof PlanPostRequestNodesInnerAnyOf1TypeEnum[keyof typeof PlanPostRequestNodesInnerAnyOf1TypeEnum];

export interface PlanPostRequestNodesInnerAnyOf2 {
    'id': string;
    'type': PlanPostRequestNodesInnerAnyOf2TypeEnum;
    'assertions': Array<PlanPostRequestNodesInnerAnyOf2AssertionsInner>;
}

export const PlanPostRequestNodesInnerAnyOf2TypeEnum = {
    Assertion: 'ASSERTION'
} as const;

export type PlanPostRequestNodesInnerAnyOf2TypeEnum = typeof PlanPostRequestNodesInnerAnyOf2TypeEnum[keyof typeof PlanPostRequestNodesInnerAnyOf2TypeEnum];

export interface PlanPostRequestNodesInnerAnyOf2AssertionsInner {
    'assertionType': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAssertionTypeEnum;
    'nodeId': string;
    'accessor': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfAccessor;
    'path': string;
    'predicate': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicate;
    'expected': any;
}

export const PlanPostRequestNodesInnerAnyOf2AssertionsInnerAssertionTypeEnum = {
    Text: 'TEXT'
} as const;

export type PlanPostRequestNodesInnerAnyOf2AssertionsInnerAssertionTypeEnum = typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAssertionTypeEnum[keyof typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAssertionTypeEnum];

export interface PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf {
    'assertionType': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAssertionTypeEnum;
    'nodeId': string;
    'accessor': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfAccessor;
    'path': Array<string>;
    'predicate': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicate;
}

export const PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAssertionTypeEnum = {
    Json: 'JSON'
} as const;

export type PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAssertionTypeEnum = typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAssertionTypeEnum[keyof typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAssertionTypeEnum];

export interface PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf1 {
    'assertionType': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf1AssertionTypeEnum;
    'path': Array<string>;
    'expected': any;
}

export const PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf1AssertionTypeEnum = {
    Xml: 'XML'
} as const;

export type PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf1AssertionTypeEnum = typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf1AssertionTypeEnum[keyof typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf1AssertionTypeEnum];

export interface PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf2 {
    'assertionType': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf2AssertionTypeEnum;
    'path': string;
    'expected': any;
}

export const PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf2AssertionTypeEnum = {
    Text: 'TEXT'
} as const;

export type PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf2AssertionTypeEnum = typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf2AssertionTypeEnum[keyof typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOf2AssertionTypeEnum];


export const PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfAccessor = {
    Body: 'body',
    Headers: 'headers',
    Status: 'status'
} as const;

export type PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfAccessor = typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfAccessor[keyof typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfAccessor];


export interface PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicate {
    'expected': any;
    'operator': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateOperatorEnum;
}

export const PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateOperatorEnum = {
    Equal: 'EQUAL',
    NotEqual: 'NOT_EQUAL',
    GreaterThan: 'GREATER_THAN',
    LessThan: 'LESS_THAN',
    GreaterThanOrEqual: 'GREATER_THAN_OR_EQUAL',
    LessThanOrEqual: 'LESS_THAN_OR_EQUAL',
    Contains: 'CONTAINS',
    NotContains: 'NOT_CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    NotStartsWith: 'NOT_STARTS_WITH',
    NotEndsWith: 'NOT_ENDS_WITH'
} as const;

export type PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateOperatorEnum = typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateOperatorEnum[keyof typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateOperatorEnum];

export interface PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateAnyOf {
    'expected': any;
    'operator': PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateAnyOfOperatorEnum;
}

export const PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateAnyOfOperatorEnum = {
    Equal: 'EQUAL',
    NotEqual: 'NOT_EQUAL',
    GreaterThan: 'GREATER_THAN',
    LessThan: 'LESS_THAN',
    GreaterThanOrEqual: 'GREATER_THAN_OR_EQUAL',
    LessThanOrEqual: 'LESS_THAN_OR_EQUAL',
    Contains: 'CONTAINS',
    NotContains: 'NOT_CONTAINS',
    StartsWith: 'STARTS_WITH',
    EndsWith: 'ENDS_WITH',
    NotStartsWith: 'NOT_STARTS_WITH',
    NotEndsWith: 'NOT_ENDS_WITH'
} as const;

export type PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateAnyOfOperatorEnum = typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateAnyOfOperatorEnum[keyof typeof PlanPostRequestNodesInnerAnyOf2AssertionsInnerAnyOfAllOfPredicateAnyOfOperatorEnum];

export interface PlanPostRequestNodesInnerAnyOfHeadersValue {
    '$secret': PlanPostRequestNodesInnerAnyOfHeadersValueAnyOfSecret;
}
export interface PlanPostRequestNodesInnerAnyOfHeadersValueAnyOf {
    '$secret': PlanPostRequestNodesInnerAnyOfHeadersValueAnyOfSecret;
}
export interface PlanPostRequestNodesInnerAnyOfHeadersValueAnyOfSecret {
    'provider': string;
    'ref': string;
    'version'?: string;
    'field'?: string;
}
export interface PlanPostRequestNodesInnerAnyOfPath {
    '$variable': PlanPostRequestNodesInnerAnyOfPathAnyOfVariable;
}
export interface PlanPostRequestNodesInnerAnyOfPathAnyOf {
    '$variable': PlanPostRequestNodesInnerAnyOfPathAnyOfVariable;
}
export interface PlanPostRequestNodesInnerAnyOfPathAnyOfVariable {
    'key': string;
    'template'?: string;
}

export const ResponseFormat = {
    Json: 'JSON',
    Xml: 'XML',
    Text: 'TEXT'
} as const;

export type ResponseFormat = typeof ResponseFormat[keyof typeof ResponseFormat];


export interface RunsGet200Response {
    'data': Array<RunsGet200ResponseDataInner>;
    'total': number;
    'page': number;
    'limit': number;
}
export interface RunsGet200ResponseDataInner {
    'id': string;
    'planId': string;
    'executionGroupId': string;
    'location': string;
    'environment': string;
    'status': RunsGet200ResponseDataInnerStatusEnum;
    'triggeredBy': RunsGet200ResponseDataInnerTriggeredByEnum;
    'startedAt': string;
    'completedAt'?: string;
    'duration_ms'?: number;
    'success'?: boolean;
    'errors'?: Array<string>;
}

export const RunsGet200ResponseDataInnerStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type RunsGet200ResponseDataInnerStatusEnum = typeof RunsGet200ResponseDataInnerStatusEnum[keyof typeof RunsGet200ResponseDataInnerStatusEnum];
export const RunsGet200ResponseDataInnerTriggeredByEnum = {
    Schedule: 'schedule',
    Manual: 'manual',
    Api: 'api'
} as const;

export type RunsGet200ResponseDataInnerTriggeredByEnum = typeof RunsGet200ResponseDataInnerTriggeredByEnum[keyof typeof RunsGet200ResponseDataInnerTriggeredByEnum];

export interface RunsIdGet200Response {
    'data': RunsIdGet200ResponseData;
}
export interface RunsIdGet200ResponseData {
    'id': string;
    'planId': string;
    'executionGroupId': string;
    'location': string;
    'environment': string;
    'status': RunsIdGet200ResponseDataStatusEnum;
    'triggeredBy': RunsIdGet200ResponseDataTriggeredByEnum;
    'startedAt': string;
    'completedAt'?: string;
    'duration_ms'?: number;
    'success'?: boolean;
    'errors'?: Array<string>;
}

export const RunsIdGet200ResponseDataStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type RunsIdGet200ResponseDataStatusEnum = typeof RunsIdGet200ResponseDataStatusEnum[keyof typeof RunsIdGet200ResponseDataStatusEnum];
export const RunsIdGet200ResponseDataTriggeredByEnum = {
    Schedule: 'schedule',
    Manual: 'manual',
    Api: 'api'
} as const;

export type RunsIdGet200ResponseDataTriggeredByEnum = typeof RunsIdGet200ResponseDataTriggeredByEnum[keyof typeof RunsIdGet200ResponseDataTriggeredByEnum];

export interface RunsIdPatchRequest {
    'status'?: RunsIdPatchRequestStatusEnum;
    'completedAt'?: string;
    'duration_ms'?: number;
    'success'?: boolean;
    'errors'?: Array<string>;
}

export const RunsIdPatchRequestStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type RunsIdPatchRequestStatusEnum = typeof RunsIdPatchRequestStatusEnum[keyof typeof RunsIdPatchRequestStatusEnum];

export interface RunsTriggerPlanIdPostRequest {
    'environment': string;
}
export interface TestPlanV1 {
    'project': string;
    'locations'?: Array<string>;
    'id': string;
    'name': string;
    'version': TestPlanV1VersionEnum;
    'frequency': Frequency1;
    'environment': string;
    'nodes': Array<Node1>;
    'edges': Array<Edge1>;
}

export const TestPlanV1VersionEnum = {
    _10: '1.0'
} as const;

export type TestPlanV1VersionEnum = typeof TestPlanV1VersionEnum[keyof typeof TestPlanV1VersionEnum];


export const UnaryPredicate = {
    IsNull: 'IS_NULL',
    IsNotNull: 'IS_NOT_NULL',
    IsTrue: 'IS_TRUE',
    IsFalse: 'IS_FALSE',
    IsEmpty: 'IS_EMPTY',
    IsNotEmpty: 'IS_NOT_EMPTY'
} as const;

export type UnaryPredicate = typeof UnaryPredicate[keyof typeof UnaryPredicate];


export interface Wait {
    'id': string;
    'type': WaitTypeEnum;
    'duration_ms': number;
}

export const WaitTypeEnum = {
    Wait: 'WAIT'
} as const;

export type WaitTypeEnum = typeof WaitTypeEnum[keyof typeof WaitTypeEnum];

export interface Wait1 {
    'id': string;
    'type': Wait1TypeEnum;
    'duration_ms': number;
}

export const Wait1TypeEnum = {
    Wait: 'WAIT'
} as const;

export type Wait1TypeEnum = typeof Wait1TypeEnum[keyof typeof Wait1TypeEnum];


/**
 * AgentsApi - axios parameter creator
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all agents with optional filtering
         * @param {string} [location] Filter by location
         * @param {AgentsGetStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsGet: async (location?: string, status?: AgentsGetStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deregister an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsIdDelete', 'id', id)
            const localVarPath = `/agents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record a heartbeat from an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdHeartbeatPost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsIdHeartbeatPost', 'id', id)
            const localVarPath = `/agents/{id}/heartbeat`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all registered locations (with at least one online agent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsLocationsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agents/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new agent with the hub
         * @param {AgentsRegisterPostRequest} agentsRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsRegisterPost: async (agentsRegisterPostRequest: AgentsRegisterPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentsRegisterPostRequest' is not null or undefined
            assertParamExists('agentsRegisterPost', 'agentsRegisterPostRequest', agentsRegisterPostRequest)
            const localVarPath = `/agents/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentsRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all agents with optional filtering
         * @param {string} [location] Filter by location
         * @param {AgentsGetStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsGet(location?: string, status?: AgentsGetStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsGet(location, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deregister an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsIdHeartbeatPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Record a heartbeat from an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsIdHeartbeatPost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsIdHeartbeatPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsIdHeartbeatPost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsIdHeartbeatPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all registered locations (with at least one online agent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsLocationsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsLocationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsLocationsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsLocationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new agent with the hub
         * @param {AgentsRegisterPostRequest} agentsRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsRegisterPost(agentsRegisterPostRequest: AgentsRegisterPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsRegisterPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsRegisterPost(agentsRegisterPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.agentsRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentsApi - factory interface
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentsApiFp(configuration)
    return {
        /**
         * List all agents with optional filtering
         * @param {string} [location] Filter by location
         * @param {AgentsGetStatusEnum} [status] Filter by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsGet(location?: string, status?: AgentsGetStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<AgentsGet200Response> {
            return localVarFp.agentsGet(location, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Deregister an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AgentsIdHeartbeatPost200Response> {
            return localVarFp.agentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Record a heartbeat from an agent
         * @param {string} id Agent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdHeartbeatPost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AgentsIdHeartbeatPost200Response> {
            return localVarFp.agentsIdHeartbeatPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all registered locations (with at least one online agent)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsLocationsGet(options?: RawAxiosRequestConfig): AxiosPromise<AgentsLocationsGet200Response> {
            return localVarFp.agentsLocationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new agent with the hub
         * @param {AgentsRegisterPostRequest} agentsRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsRegisterPost(agentsRegisterPostRequest: AgentsRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentsRegisterPost200Response> {
            return localVarFp.agentsRegisterPost(agentsRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 */
export class AgentsApi extends BaseAPI {
    /**
     * List all agents with optional filtering
     * @param {string} [location] Filter by location
     * @param {AgentsGetStatusEnum} [status] Filter by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsGet(location?: string, status?: AgentsGetStatusEnum, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsGet(location, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deregister an agent
     * @param {string} id Agent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Record a heartbeat from an agent
     * @param {string} id Agent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsIdHeartbeatPost(id: string, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsIdHeartbeatPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all registered locations (with at least one online agent)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsLocationsGet(options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsLocationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new agent with the hub
     * @param {AgentsRegisterPostRequest} agentsRegisterPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public agentsRegisterPost(agentsRegisterPostRequest: AgentsRegisterPostRequest, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).agentsRegisterPost(agentsRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const AgentsGetStatusEnum = {
    Online: 'online',
    Offline: 'offline'
} as const;
export type AgentsGetStatusEnum = typeof AgentsGetStatusEnum[keyof typeof AgentsGetStatusEnum];


/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlanApi - axios parameter creator
 */
export const PlanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} projectId 
         * @param {string} environment 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planByNameGet: async (projectId: string, environment: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('planByNameGet', 'projectId', projectId)
            // verify required parameter 'environment' is not null or undefined
            assertParamExists('planByNameGet', 'environment', environment)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('planByNameGet', 'name', name)
            const localVarPath = `/plan/by-name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [projectId] 
         * @param {string} [environment] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planGet: async (projectId?: string, environment?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('planIdDelete', 'id', id)
            const localVarPath = `/plan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PlanPostRequest} planPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planIdPut: async (id: string, planPostRequest: PlanPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('planIdPut', 'id', id)
            // verify required parameter 'planPostRequest' is not null or undefined
            assertParamExists('planIdPut', 'planPostRequest', planPostRequest)
            const localVarPath = `/plan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(planPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PlanPostRequest} planPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planPost: async (planPostRequest: PlanPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planPostRequest' is not null or undefined
            assertParamExists('planPost', 'planPostRequest', planPostRequest)
            const localVarPath = `/plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(planPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanApi - functional programming interface
 */
export const PlanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlanApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} projectId 
         * @param {string} environment 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async planByNameGet(projectId: string, environment: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.planByNameGet(projectId, environment, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanApi.planByNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [projectId] 
         * @param {string} [environment] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async planGet(projectId?: string, environment?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.planGet(projectId, environment, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanApi.planGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async planIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.planIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanApi.planIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PlanPostRequest} planPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async planIdPut(id: string, planPostRequest: PlanPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.planIdPut(id, planPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanApi.planIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PlanPostRequest} planPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async planPost(planPostRequest: PlanPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.planPost(planPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanApi.planPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlanApi - factory interface
 */
export const PlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlanApiFp(configuration)
    return {
        /**
         * 
         * @param {string} projectId 
         * @param {string} environment 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planByNameGet(projectId: string, environment: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<PlanPost201Response> {
            return localVarFp.planByNameGet(projectId, environment, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [projectId] 
         * @param {string} [environment] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planGet(projectId?: string, environment?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PlanGet200Response> {
            return localVarFp.planGet(projectId, environment, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.planIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PlanPostRequest} planPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planIdPut(id: string, planPostRequest: PlanPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlanPost201Response> {
            return localVarFp.planIdPut(id, planPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PlanPostRequest} planPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planPost(planPostRequest: PlanPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlanPost201Response> {
            return localVarFp.planPost(planPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlanApi - object-oriented interface
 */
export class PlanApi extends BaseAPI {
    /**
     * 
     * @param {string} projectId 
     * @param {string} environment 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public planByNameGet(projectId: string, environment: string, name: string, options?: RawAxiosRequestConfig) {
        return PlanApiFp(this.configuration).planByNameGet(projectId, environment, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [projectId] 
     * @param {string} [environment] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public planGet(projectId?: string, environment?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return PlanApiFp(this.configuration).planGet(projectId, environment, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public planIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PlanApiFp(this.configuration).planIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PlanPostRequest} planPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public planIdPut(id: string, planPostRequest: PlanPostRequest, options?: RawAxiosRequestConfig) {
        return PlanApiFp(this.configuration).planIdPut(id, planPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlanPostRequest} planPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public planPost(planPostRequest: PlanPostRequest, options?: RawAxiosRequestConfig) {
        return PlanApiFp(this.configuration).planPost(planPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunsApi - axios parameter creator
 */
export const RunsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [planId] 
         * @param {RunsGetStatusEnum} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsGet: async (planId?: string, status?: RunsGetStatusEnum, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/runs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (planId !== undefined) {
                localVarQueryParameter['planId'] = planId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runsIdGet', 'id', id)
            const localVarPath = `/runs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {RunsIdPatchRequest} [runsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsIdPatch: async (id: string, runsIdPatchRequest?: RunsIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runsIdPatch', 'id', id)
            const localVarPath = `/runs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} planId 
         * @param {RunsTriggerPlanIdPostRequest} runsTriggerPlanIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsTriggerPlanIdPost: async (planId: string, runsTriggerPlanIdPostRequest: RunsTriggerPlanIdPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('runsTriggerPlanIdPost', 'planId', planId)
            // verify required parameter 'runsTriggerPlanIdPostRequest' is not null or undefined
            assertParamExists('runsTriggerPlanIdPost', 'runsTriggerPlanIdPostRequest', runsTriggerPlanIdPostRequest)
            const localVarPath = `/runs/trigger/{planId}`
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runsTriggerPlanIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsApi - functional programming interface
 */
export const RunsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [planId] 
         * @param {RunsGetStatusEnum} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runsGet(planId?: string, status?: RunsGetStatusEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runsGet(planId, status, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunsApi.runsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunsApi.runsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {RunsIdPatchRequest} [runsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runsIdPatch(id: string, runsIdPatchRequest?: RunsIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runsIdPatch(id, runsIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunsApi.runsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} planId 
         * @param {RunsTriggerPlanIdPostRequest} runsTriggerPlanIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runsTriggerPlanIdPost(planId: string, runsTriggerPlanIdPostRequest: RunsTriggerPlanIdPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runsTriggerPlanIdPost(planId, runsTriggerPlanIdPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunsApi.runsTriggerPlanIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunsApi - factory interface
 */
export const RunsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [planId] 
         * @param {RunsGetStatusEnum} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsGet(planId?: string, status?: RunsGetStatusEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<RunsGet200Response> {
            return localVarFp.runsGet(planId, status, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RunsIdGet200Response> {
            return localVarFp.runsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {RunsIdPatchRequest} [runsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsIdPatch(id: string, runsIdPatchRequest?: RunsIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunsIdGet200Response> {
            return localVarFp.runsIdPatch(id, runsIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} planId 
         * @param {RunsTriggerPlanIdPostRequest} runsTriggerPlanIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runsTriggerPlanIdPost(planId: string, runsTriggerPlanIdPostRequest: RunsTriggerPlanIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunsIdGet200Response> {
            return localVarFp.runsTriggerPlanIdPost(planId, runsTriggerPlanIdPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunsApi - object-oriented interface
 */
export class RunsApi extends BaseAPI {
    /**
     * 
     * @param {string} [planId] 
     * @param {RunsGetStatusEnum} [status] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runsGet(planId?: string, status?: RunsGetStatusEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return RunsApiFp(this.configuration).runsGet(planId, status, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return RunsApiFp(this.configuration).runsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {RunsIdPatchRequest} [runsIdPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runsIdPatch(id: string, runsIdPatchRequest?: RunsIdPatchRequest, options?: RawAxiosRequestConfig) {
        return RunsApiFp(this.configuration).runsIdPatch(id, runsIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} planId 
     * @param {RunsTriggerPlanIdPostRequest} runsTriggerPlanIdPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public runsTriggerPlanIdPost(planId: string, runsTriggerPlanIdPostRequest: RunsTriggerPlanIdPostRequest, options?: RawAxiosRequestConfig) {
        return RunsApiFp(this.configuration).runsTriggerPlanIdPost(planId, runsTriggerPlanIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const RunsGetStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Completed: 'completed',
    Failed: 'failed'
} as const;
export type RunsGetStatusEnum = typeof RunsGetStatusEnum[keyof typeof RunsGetStatusEnum];


