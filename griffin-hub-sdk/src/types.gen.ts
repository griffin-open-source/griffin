// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseURL: "http://localhost:3000" | (string & {});
};

/**
 * PlanV1
 */
export type PlanV1 = {
  project: string;
  locations?: Array<string>;
  id: string;
  name: string;
  version: "1.0";
  /**
   * Frequency
   */
  frequency: {
    every: number;
    /**
     * FrequencyUnit
     */
    unit: "MINUTE" | "HOUR" | "DAY";
  };
  environment: string;
  /**
   * Node
   */
  nodes: Array<
    | {
        id: string;
        type: "ENDPOINT";
        /**
         * HttpMethod
         */
        method:
          | "GET"
          | "POST"
          | "PUT"
          | "DELETE"
          | "PATCH"
          | "HEAD"
          | "OPTIONS"
          | "CONNECT"
          | "TRACE";
        path: string;
        base: string;
        headers?: {
          [key: string]:
            | {
                $secret: {
                  provider: string;
                  ref: string;
                  version?: string;
                  field?: string;
                };
              }
            | {
                $literal: string;
              };
        };
        body?: unknown;
        /**
         * ResponseFormat
         */
        response_format: "JSON" | "XML" | "TEXT";
      }
    | {
        id: string;
        type: "WAIT";
        duration_ms: number;
      }
    | {
        id: string;
        type: "ASSERTION";
        /**
         * Assertion
         */
        assertions: Array<
          | {
              nodeId: string;
              /**
               * JSONAccessor
               */
              accessor: "body" | "headers" | "status";
              path: Array<string>;
              predicate:
                | "IS_NULL"
                | "IS_NOT_NULL"
                | "IS_TRUE"
                | "IS_FALSE"
                | "IS_EMPTY"
                | "IS_NOT_EMPTY"
                | {
                    expected: unknown;
                    /**
                     * BinaryPredicateOperator
                     */
                    operator:
                      | "EQUAL"
                      | "NOT_EQUAL"
                      | "GREATER_THAN"
                      | "LESS_THAN"
                      | "GREATER_THAN_OR_EQUAL"
                      | "LESS_THAN_OR_EQUAL"
                      | "CONTAINS"
                      | "NOT_CONTAINS"
                      | "STARTS_WITH"
                      | "ENDS_WITH"
                      | "NOT_STARTS_WITH"
                      | "NOT_ENDS_WITH";
                  };
              assertionType: "JSON";
            }
          | {
              nodeId: string;
              path: Array<string>;
              expected: unknown;
              assertionType: "XML";
            }
          | {
              nodeId: string;
              path: string;
              expected: unknown;
              assertionType: "TEXT";
            }
        >;
      }
  >;
  edges: Array<{
    from: string;
    to: string;
  }>;
};

/**
 * Frequency
 */
export type Frequency = {
  every: number;
  /**
   * FrequencyUnit
   */
  unit: "MINUTE" | "HOUR" | "DAY";
};

/**
 * FrequencyUnit
 */
export type FrequencyUnit = "MINUTE" | "HOUR" | "DAY";

/**
 * Node
 */
export type Node =
  | {
      id: string;
      type: "ENDPOINT";
      /**
       * HttpMethod
       */
      method:
        | "GET"
        | "POST"
        | "PUT"
        | "DELETE"
        | "PATCH"
        | "HEAD"
        | "OPTIONS"
        | "CONNECT"
        | "TRACE";
      path: string;
      base: string;
      headers?: {
        [key: string]:
          | {
              $secret: {
                provider: string;
                ref: string;
                version?: string;
                field?: string;
              };
            }
          | {
              $literal: string;
            };
      };
      body?: unknown;
      /**
       * ResponseFormat
       */
      response_format: "JSON" | "XML" | "TEXT";
    }
  | {
      id: string;
      type: "WAIT";
      duration_ms: number;
    }
  | {
      id: string;
      type: "ASSERTION";
      /**
       * Assertion
       */
      assertions: Array<
        | {
            nodeId: string;
            /**
             * JSONAccessor
             */
            accessor: "body" | "headers" | "status";
            path: Array<string>;
            predicate:
              | "IS_NULL"
              | "IS_NOT_NULL"
              | "IS_TRUE"
              | "IS_FALSE"
              | "IS_EMPTY"
              | "IS_NOT_EMPTY"
              | {
                  expected: unknown;
                  /**
                   * BinaryPredicateOperator
                   */
                  operator:
                    | "EQUAL"
                    | "NOT_EQUAL"
                    | "GREATER_THAN"
                    | "LESS_THAN"
                    | "GREATER_THAN_OR_EQUAL"
                    | "LESS_THAN_OR_EQUAL"
                    | "CONTAINS"
                    | "NOT_CONTAINS"
                    | "STARTS_WITH"
                    | "ENDS_WITH"
                    | "NOT_STARTS_WITH"
                    | "NOT_ENDS_WITH";
                };
            assertionType: "JSON";
          }
        | {
            nodeId: string;
            path: Array<string>;
            expected: unknown;
            assertionType: "XML";
          }
        | {
            nodeId: string;
            path: string;
            expected: unknown;
            assertionType: "TEXT";
          }
      >;
    };

/**
 * Endpoint
 */
export type Endpoint = {
  id: string;
  type: "ENDPOINT";
  /**
   * HttpMethod
   */
  method:
    | "GET"
    | "POST"
    | "PUT"
    | "DELETE"
    | "PATCH"
    | "HEAD"
    | "OPTIONS"
    | "CONNECT"
    | "TRACE";
  path: string;
  base: string;
  headers?: {
    [key: string]:
      | {
          $secret: {
            provider: string;
            ref: string;
            version?: string;
            field?: string;
          };
        }
      | {
          $literal: string;
        };
  };
  body?: unknown;
  /**
   * ResponseFormat
   */
  response_format: "JSON" | "XML" | "TEXT";
};

/**
 * HttpMethod
 */
export type HttpMethod =
  | "GET"
  | "POST"
  | "PUT"
  | "DELETE"
  | "PATCH"
  | "HEAD"
  | "OPTIONS"
  | "CONNECT"
  | "TRACE";

/**
 * SecretOrString
 */
export type SecretOrString =
  | {
      $secret: {
        provider: string;
        ref: string;
        version?: string;
        field?: string;
      };
    }
  | {
      $literal: string;
    };

/**
 * SecretRef
 */
export type SecretRef = {
  $secret: {
    provider: string;
    ref: string;
    version?: string;
    field?: string;
  };
};

/**
 * StringLiteral
 */
export type StringLiteral = {
  $literal: string;
};

/**
 * ResponseFormat
 */
export type ResponseFormat = "JSON" | "XML" | "TEXT";

/**
 * Wait
 */
export type Wait = {
  id: string;
  type: "WAIT";
  duration_ms: number;
};

/**
 * Assertions
 */
export type Assertions = {
  id: string;
  type: "ASSERTION";
  /**
   * Assertion
   */
  assertions: Array<
    | {
        nodeId: string;
        /**
         * JSONAccessor
         */
        accessor: "body" | "headers" | "status";
        path: Array<string>;
        predicate:
          | "IS_NULL"
          | "IS_NOT_NULL"
          | "IS_TRUE"
          | "IS_FALSE"
          | "IS_EMPTY"
          | "IS_NOT_EMPTY"
          | {
              expected: unknown;
              /**
               * BinaryPredicateOperator
               */
              operator:
                | "EQUAL"
                | "NOT_EQUAL"
                | "GREATER_THAN"
                | "LESS_THAN"
                | "GREATER_THAN_OR_EQUAL"
                | "LESS_THAN_OR_EQUAL"
                | "CONTAINS"
                | "NOT_CONTAINS"
                | "STARTS_WITH"
                | "ENDS_WITH"
                | "NOT_STARTS_WITH"
                | "NOT_ENDS_WITH";
            };
        assertionType: "JSON";
      }
    | {
        nodeId: string;
        path: Array<string>;
        expected: unknown;
        assertionType: "XML";
      }
    | {
        nodeId: string;
        path: string;
        expected: unknown;
        assertionType: "TEXT";
      }
  >;
};

/**
 * Assertion
 */
export type Assertion =
  | {
      nodeId: string;
      /**
       * JSONAccessor
       */
      accessor: "body" | "headers" | "status";
      path: Array<string>;
      predicate:
        | "IS_NULL"
        | "IS_NOT_NULL"
        | "IS_TRUE"
        | "IS_FALSE"
        | "IS_EMPTY"
        | "IS_NOT_EMPTY"
        | {
            expected: unknown;
            /**
             * BinaryPredicateOperator
             */
            operator:
              | "EQUAL"
              | "NOT_EQUAL"
              | "GREATER_THAN"
              | "LESS_THAN"
              | "GREATER_THAN_OR_EQUAL"
              | "LESS_THAN_OR_EQUAL"
              | "CONTAINS"
              | "NOT_CONTAINS"
              | "STARTS_WITH"
              | "ENDS_WITH"
              | "NOT_STARTS_WITH"
              | "NOT_ENDS_WITH";
          };
      assertionType: "JSON";
    }
  | {
      nodeId: string;
      path: Array<string>;
      expected: unknown;
      assertionType: "XML";
    }
  | {
      nodeId: string;
      path: string;
      expected: unknown;
      assertionType: "TEXT";
    };

/**
 * JSONAssertion
 */
export type JsonAssertion = {
  nodeId: string;
  /**
   * JSONAccessor
   */
  accessor: "body" | "headers" | "status";
  path: Array<string>;
  predicate:
    | "IS_NULL"
    | "IS_NOT_NULL"
    | "IS_TRUE"
    | "IS_FALSE"
    | "IS_EMPTY"
    | "IS_NOT_EMPTY"
    | {
        expected: unknown;
        /**
         * BinaryPredicateOperator
         */
        operator:
          | "EQUAL"
          | "NOT_EQUAL"
          | "GREATER_THAN"
          | "LESS_THAN"
          | "GREATER_THAN_OR_EQUAL"
          | "LESS_THAN_OR_EQUAL"
          | "CONTAINS"
          | "NOT_CONTAINS"
          | "STARTS_WITH"
          | "ENDS_WITH"
          | "NOT_STARTS_WITH"
          | "NOT_ENDS_WITH";
      };
  assertionType: "JSON";
};

/**
 * JSONAccessor
 */
export type JsonAccessor = "body" | "headers" | "status";

/**
 * UnaryPredicate
 */
export type UnaryPredicate =
  | "IS_NULL"
  | "IS_NOT_NULL"
  | "IS_TRUE"
  | "IS_FALSE"
  | "IS_EMPTY"
  | "IS_NOT_EMPTY";

/**
 * BinaryPredicate
 */
export type BinaryPredicate = {
  expected: unknown;
  /**
   * BinaryPredicateOperator
   */
  operator:
    | "EQUAL"
    | "NOT_EQUAL"
    | "GREATER_THAN"
    | "LESS_THAN"
    | "GREATER_THAN_OR_EQUAL"
    | "LESS_THAN_OR_EQUAL"
    | "CONTAINS"
    | "NOT_CONTAINS"
    | "STARTS_WITH"
    | "ENDS_WITH"
    | "NOT_STARTS_WITH"
    | "NOT_ENDS_WITH";
};

/**
 * BinaryPredicateOperator
 */
export type BinaryPredicateOperator =
  | "EQUAL"
  | "NOT_EQUAL"
  | "GREATER_THAN"
  | "LESS_THAN"
  | "GREATER_THAN_OR_EQUAL"
  | "LESS_THAN_OR_EQUAL"
  | "CONTAINS"
  | "NOT_CONTAINS"
  | "STARTS_WITH"
  | "ENDS_WITH"
  | "NOT_STARTS_WITH"
  | "NOT_ENDS_WITH";

/**
 * XMLAssertion
 */
export type XmlAssertion = {
  nodeId: string;
  path: Array<string>;
  expected: unknown;
  assertionType: "XML";
};

/**
 * TextAssertion
 */
export type TextAssertion = {
  nodeId: string;
  path: string;
  expected: unknown;
  assertionType: "TEXT";
};

/**
 * Edge
 */
export type Edge = {
  from: string;
  to: string;
};

export type GetData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/";
};

export type GetResponses = {
  /**
   * Default Response
   */
  200: unknown;
};

export type PostAgentsRegisterData = {
  body: {
    location: string;
    metadata?: {
      [key: string]: string;
    };
  };
  path?: never;
  query?: never;
  url: "/agents/register";
};

export type PostAgentsRegisterResponses = {
  /**
   * Default Response
   */
  200: {
    id: string;
    location: string;
    /**
     * AgentStatus
     */
    status: "online" | "offline";
    lastHeartbeat: string;
    registeredAt: string;
    metadata?: {
      [key: string]: string;
    };
  };
};

export type PostAgentsRegisterResponse =
  PostAgentsRegisterResponses[keyof PostAgentsRegisterResponses];

export type PostAgentsByIdHeartbeatData = {
  body?: never;
  path: {
    /**
     * Agent ID
     */
    id: string;
  };
  query?: never;
  url: "/agents/{id}/heartbeat";
};

export type PostAgentsByIdHeartbeatErrors = {
  /**
   * Default Response
   */
  404: {
    error: string;
  };
};

export type PostAgentsByIdHeartbeatError =
  PostAgentsByIdHeartbeatErrors[keyof PostAgentsByIdHeartbeatErrors];

export type PostAgentsByIdHeartbeatResponses = {
  /**
   * Default Response
   */
  200: {
    success: boolean;
  };
};

export type PostAgentsByIdHeartbeatResponse =
  PostAgentsByIdHeartbeatResponses[keyof PostAgentsByIdHeartbeatResponses];

export type DeleteAgentsByIdData = {
  body?: never;
  path: {
    /**
     * Agent ID
     */
    id: string;
  };
  query?: never;
  url: "/agents/{id}";
};

export type DeleteAgentsByIdResponses = {
  /**
   * Default Response
   */
  200: {
    success: boolean;
  };
};

export type DeleteAgentsByIdResponse =
  DeleteAgentsByIdResponses[keyof DeleteAgentsByIdResponses];

export type GetAgentsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by location
     */
    location?: string;
    /**
     * Filter by status
     */
    status?: "online" | "offline";
  };
  url: "/agents/";
};

export type GetAgentsResponses = {
  /**
   * Default Response
   */
  200: {
    data: Array<{
      id: string;
      location: string;
      status: "online" | "offline";
      lastHeartbeat: string;
      registeredAt: string;
      metadata?: {
        [key: string]: string;
      };
    }>;
    total: number;
  };
};

export type GetAgentsResponse = GetAgentsResponses[keyof GetAgentsResponses];

export type GetAgentsLocationsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/agents/locations";
};

export type GetAgentsLocationsResponses = {
  /**
   * Default Response
   */
  200: {
    locations: Array<string>;
  };
};

export type GetAgentsLocationsResponse =
  GetAgentsLocationsResponses[keyof GetAgentsLocationsResponses];

export type GetPlanData = {
  body?: never;
  path?: never;
  query?: {
    projectId?: string;
    environment?: string;
    limit?: number;
    offset?: number;
  };
  url: "/plan/";
};

export type GetPlanErrors = {
  /**
   * Default Response
   */
  400: {
    error: string;
  };
  /**
   * Default Response
   */
  401: {
    error: string;
  };
  /**
   * Default Response
   */
  403: {
    error: string;
  };
  /**
   * Default Response
   */
  404: {
    error: string;
  };
  /**
   * Default Response
   */
  500: {
    error: string;
  };
  /**
   * Default Response
   */
  502: {
    error: string;
  };
  /**
   * Default Response
   */
  503: {
    error: string;
  };
  /**
   * Default Response
   */
  504: {
    error: string;
  };
};

export type GetPlanError = GetPlanErrors[keyof GetPlanErrors];

export type GetPlanResponses = {
  /**
   * Default Response
   */
  200: {
    data: Array<PlanV1>;
    total: number;
    page: number;
    limit: number;
  };
};

export type GetPlanResponse = GetPlanResponses[keyof GetPlanResponses];

export type PostPlanData = {
  body: {
    project: string;
    locations?: Array<string>;
    name: string;
    version: "1.0";
    frequency: {
      every: number;
      unit: "MINUTE" | "HOUR" | "DAY";
    };
    environment: string;
    nodes: Array<
      | {
          id: string;
          type: "ENDPOINT";
          method:
            | "GET"
            | "POST"
            | "PUT"
            | "DELETE"
            | "PATCH"
            | "HEAD"
            | "OPTIONS"
            | "CONNECT"
            | "TRACE";
          path: string;
          base: string;
          headers?: {
            [key: string]:
              | {
                  $secret: {
                    provider: string;
                    ref: string;
                    version?: string;
                    field?: string;
                  };
                }
              | {
                  $literal: string;
                };
          };
          body?: unknown;
          response_format: "JSON" | "XML" | "TEXT";
        }
      | {
          id: string;
          type: "WAIT";
          duration_ms: number;
        }
      | {
          id: string;
          type: "ASSERTION";
          assertions: Array<
            | {
                nodeId: string;
                accessor: "body" | "headers" | "status";
                path: Array<string>;
                predicate:
                  | "IS_NULL"
                  | "IS_NOT_NULL"
                  | "IS_TRUE"
                  | "IS_FALSE"
                  | "IS_EMPTY"
                  | "IS_NOT_EMPTY"
                  | {
                      expected: unknown;
                      operator:
                        | "EQUAL"
                        | "NOT_EQUAL"
                        | "GREATER_THAN"
                        | "LESS_THAN"
                        | "GREATER_THAN_OR_EQUAL"
                        | "LESS_THAN_OR_EQUAL"
                        | "CONTAINS"
                        | "NOT_CONTAINS"
                        | "STARTS_WITH"
                        | "ENDS_WITH"
                        | "NOT_STARTS_WITH"
                        | "NOT_ENDS_WITH";
                    };
                assertionType: "JSON";
              }
            | {
                nodeId: string;
                path: Array<string>;
                expected: unknown;
                assertionType: "XML";
              }
            | {
                nodeId: string;
                path: string;
                expected: unknown;
                assertionType: "TEXT";
              }
          >;
        }
    >;
    edges: Array<{
      from: string;
      to: string;
    }>;
  };
  path?: never;
  query?: never;
  url: "/plan/";
};

export type PostPlanErrors = {
  /**
   * Default Response
   */
  400: {
    error: string;
  };
  /**
   * Default Response
   */
  401: {
    error: string;
  };
  /**
   * Default Response
   */
  403: {
    error: string;
  };
  /**
   * Default Response
   */
  404: {
    error: string;
  };
  /**
   * Default Response
   */
  500: {
    error: string;
  };
  /**
   * Default Response
   */
  502: {
    error: string;
  };
  /**
   * Default Response
   */
  503: {
    error: string;
  };
  /**
   * Default Response
   */
  504: {
    error: string;
  };
};

export type PostPlanError = PostPlanErrors[keyof PostPlanErrors];

export type PostPlanResponses = {
  /**
   * Default Response
   */
  201: {
    data: PlanV1;
  };
};

export type PostPlanResponse = PostPlanResponses[keyof PostPlanResponses];

export type DeletePlanByIdData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/plan/{id}";
};

export type DeletePlanByIdErrors = {
  /**
   * Default Response
   */
  400: {
    error: string;
  };
  /**
   * Default Response
   */
  401: {
    error: string;
  };
  /**
   * Default Response
   */
  403: {
    error: string;
  };
  /**
   * Default Response
   */
  404: {
    error: string;
  };
  /**
   * Default Response
   */
  500: {
    error: string;
  };
  /**
   * Default Response
   */
  502: {
    error: string;
  };
  /**
   * Default Response
   */
  503: {
    error: string;
  };
  /**
   * Default Response
   */
  504: {
    error: string;
  };
};

export type DeletePlanByIdError =
  DeletePlanByIdErrors[keyof DeletePlanByIdErrors];

export type DeletePlanByIdResponses = {
  /**
   * Default Response
   */
  204: void;
};

export type DeletePlanByIdResponse =
  DeletePlanByIdResponses[keyof DeletePlanByIdResponses];

export type PutPlanByIdData = {
  body: {
    project: string;
    locations?: Array<string>;
    name: string;
    version: "1.0";
    frequency: {
      every: number;
      unit: "MINUTE" | "HOUR" | "DAY";
    };
    environment: string;
    nodes: Array<
      | {
          id: string;
          type: "ENDPOINT";
          method:
            | "GET"
            | "POST"
            | "PUT"
            | "DELETE"
            | "PATCH"
            | "HEAD"
            | "OPTIONS"
            | "CONNECT"
            | "TRACE";
          path: string;
          base: string;
          headers?: {
            [key: string]:
              | {
                  $secret: {
                    provider: string;
                    ref: string;
                    version?: string;
                    field?: string;
                  };
                }
              | {
                  $literal: string;
                };
          };
          body?: unknown;
          response_format: "JSON" | "XML" | "TEXT";
        }
      | {
          id: string;
          type: "WAIT";
          duration_ms: number;
        }
      | {
          id: string;
          type: "ASSERTION";
          assertions: Array<
            | {
                nodeId: string;
                accessor: "body" | "headers" | "status";
                path: Array<string>;
                predicate:
                  | "IS_NULL"
                  | "IS_NOT_NULL"
                  | "IS_TRUE"
                  | "IS_FALSE"
                  | "IS_EMPTY"
                  | "IS_NOT_EMPTY"
                  | {
                      expected: unknown;
                      operator:
                        | "EQUAL"
                        | "NOT_EQUAL"
                        | "GREATER_THAN"
                        | "LESS_THAN"
                        | "GREATER_THAN_OR_EQUAL"
                        | "LESS_THAN_OR_EQUAL"
                        | "CONTAINS"
                        | "NOT_CONTAINS"
                        | "STARTS_WITH"
                        | "ENDS_WITH"
                        | "NOT_STARTS_WITH"
                        | "NOT_ENDS_WITH";
                    };
                assertionType: "JSON";
              }
            | {
                nodeId: string;
                path: Array<string>;
                expected: unknown;
                assertionType: "XML";
              }
            | {
                nodeId: string;
                path: string;
                expected: unknown;
                assertionType: "TEXT";
              }
          >;
        }
    >;
    edges: Array<{
      from: string;
      to: string;
    }>;
  };
  path: {
    id: string;
  };
  query?: never;
  url: "/plan/{id}";
};

export type PutPlanByIdErrors = {
  /**
   * Default Response
   */
  400: {
    error: string;
  };
  /**
   * Default Response
   */
  401: {
    error: string;
  };
  /**
   * Default Response
   */
  403: {
    error: string;
  };
  /**
   * Default Response
   */
  404: {
    error: string;
  };
  /**
   * Default Response
   */
  500: {
    error: string;
  };
  /**
   * Default Response
   */
  502: {
    error: string;
  };
  /**
   * Default Response
   */
  503: {
    error: string;
  };
  /**
   * Default Response
   */
  504: {
    error: string;
  };
};

export type PutPlanByIdError = PutPlanByIdErrors[keyof PutPlanByIdErrors];

export type PutPlanByIdResponses = {
  /**
   * Default Response
   */
  200: {
    data: PlanV1;
  };
};

export type PutPlanByIdResponse =
  PutPlanByIdResponses[keyof PutPlanByIdResponses];

export type GetPlanByNameData = {
  body?: never;
  path?: never;
  query: {
    projectId: string;
    environment: string;
    name: string;
  };
  url: "/plan/by-name";
};

export type GetPlanByNameErrors = {
  /**
   * Default Response
   */
  400: {
    error: string;
  };
  /**
   * Default Response
   */
  401: {
    error: string;
  };
  /**
   * Default Response
   */
  403: {
    error: string;
  };
  /**
   * Default Response
   */
  404: {
    error: string;
  };
  /**
   * Default Response
   */
  500: {
    error: string;
  };
  /**
   * Default Response
   */
  502: {
    error: string;
  };
  /**
   * Default Response
   */
  503: {
    error: string;
  };
  /**
   * Default Response
   */
  504: {
    error: string;
  };
};

export type GetPlanByNameError = GetPlanByNameErrors[keyof GetPlanByNameErrors];

export type GetPlanByNameResponses = {
  /**
   * Default Response
   */
  200: {
    data: PlanV1;
  };
};

export type GetPlanByNameResponse =
  GetPlanByNameResponses[keyof GetPlanByNameResponses];

export type GetRunsData = {
  body?: never;
  path?: never;
  query?: {
    planId?: string;
    /**
     * JobRunStatus
     */
    status?: "pending" | "running" | "completed" | "failed";
    limit?: number;
    offset?: number;
  };
  url: "/runs/";
};

export type GetRunsErrors = {
  /**
   * Default Response
   */
  400: {
    error: string;
  };
  /**
   * Default Response
   */
  401: {
    error: string;
  };
  /**
   * Default Response
   */
  403: {
    error: string;
  };
  /**
   * Default Response
   */
  404: {
    error: string;
  };
  /**
   * Default Response
   */
  500: {
    error: string;
  };
  /**
   * Default Response
   */
  502: {
    error: string;
  };
  /**
   * Default Response
   */
  503: {
    error: string;
  };
  /**
   * Default Response
   */
  504: {
    error: string;
  };
};

export type GetRunsError = GetRunsErrors[keyof GetRunsErrors];

export type GetRunsResponses = {
  /**
   * Default Response
   */
  200: {
    data: Array<{
      id: string;
      planId: string;
      executionGroupId: string;
      location: string;
      environment: string;
      status: "pending" | "running" | "completed" | "failed";
      /**
       * TriggerType
       */
      triggeredBy: "schedule" | "manual" | "api";
      startedAt: string;
      completedAt?: string;
      duration_ms?: number;
      success?: boolean;
      errors?: Array<string>;
    }>;
    total: number;
    page: number;
    limit: number;
  };
};

export type GetRunsResponse = GetRunsResponses[keyof GetRunsResponses];

export type GetRunsByIdData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/runs/{id}";
};

export type GetRunsByIdErrors = {
  /**
   * Default Response
   */
  400: {
    error: string;
  };
  /**
   * Default Response
   */
  401: {
    error: string;
  };
  /**
   * Default Response
   */
  403: {
    error: string;
  };
  /**
   * Default Response
   */
  404: {
    error: string;
  };
  /**
   * Default Response
   */
  500: {
    error: string;
  };
  /**
   * Default Response
   */
  502: {
    error: string;
  };
  /**
   * Default Response
   */
  503: {
    error: string;
  };
  /**
   * Default Response
   */
  504: {
    error: string;
  };
};

export type GetRunsByIdError = GetRunsByIdErrors[keyof GetRunsByIdErrors];

export type GetRunsByIdResponses = {
  /**
   * Default Response
   */
  200: {
    data: {
      id: string;
      planId: string;
      executionGroupId: string;
      location: string;
      environment: string;
      status: "pending" | "running" | "completed" | "failed";
      triggeredBy: "schedule" | "manual" | "api";
      startedAt: string;
      completedAt?: string;
      duration_ms?: number;
      success?: boolean;
      errors?: Array<string>;
    };
  };
};

export type GetRunsByIdResponse =
  GetRunsByIdResponses[keyof GetRunsByIdResponses];

export type PatchRunsByIdData = {
  body?: {
    status?: "pending" | "running" | "completed" | "failed";
    completedAt?: string;
    duration_ms?: number;
    success?: boolean;
    errors?: Array<string>;
  };
  path: {
    id: string;
  };
  query?: never;
  url: "/runs/{id}";
};

export type PatchRunsByIdErrors = {
  /**
   * Default Response
   */
  400: {
    error: string;
  };
  /**
   * Default Response
   */
  401: {
    error: string;
  };
  /**
   * Default Response
   */
  403: {
    error: string;
  };
  /**
   * Default Response
   */
  404: {
    error: string;
  };
  /**
   * Default Response
   */
  500: {
    error: string;
  };
  /**
   * Default Response
   */
  502: {
    error: string;
  };
  /**
   * Default Response
   */
  503: {
    error: string;
  };
  /**
   * Default Response
   */
  504: {
    error: string;
  };
};

export type PatchRunsByIdError = PatchRunsByIdErrors[keyof PatchRunsByIdErrors];

export type PatchRunsByIdResponses = {
  /**
   * Default Response
   */
  200: {
    data: {
      id: string;
      planId: string;
      executionGroupId: string;
      location: string;
      environment: string;
      status: "pending" | "running" | "completed" | "failed";
      triggeredBy: "schedule" | "manual" | "api";
      startedAt: string;
      completedAt?: string;
      duration_ms?: number;
      success?: boolean;
      errors?: Array<string>;
    };
  };
};

export type PatchRunsByIdResponse =
  PatchRunsByIdResponses[keyof PatchRunsByIdResponses];

export type PostRunsTriggerByPlanIdData = {
  body: {
    environment: string;
  };
  path: {
    planId: string;
  };
  query?: never;
  url: "/runs/trigger/{planId}";
};

export type PostRunsTriggerByPlanIdErrors = {
  /**
   * Default Response
   */
  400: {
    error: string;
  };
  /**
   * Default Response
   */
  401: {
    error: string;
  };
  /**
   * Default Response
   */
  403: {
    error: string;
  };
  /**
   * Default Response
   */
  404: {
    error: string;
  };
  /**
   * Default Response
   */
  500: {
    error: string;
  };
  /**
   * Default Response
   */
  502: {
    error: string;
  };
  /**
   * Default Response
   */
  503: {
    error: string;
  };
  /**
   * Default Response
   */
  504: {
    error: string;
  };
};

export type PostRunsTriggerByPlanIdError =
  PostRunsTriggerByPlanIdErrors[keyof PostRunsTriggerByPlanIdErrors];

export type PostRunsTriggerByPlanIdResponses = {
  /**
   * Default Response
   */
  200: {
    data: {
      id: string;
      planId: string;
      executionGroupId: string;
      location: string;
      environment: string;
      status: "pending" | "running" | "completed" | "failed";
      triggeredBy: "schedule" | "manual" | "api";
      startedAt: string;
      completedAt?: string;
      duration_ms?: number;
      success?: boolean;
      errors?: Array<string>;
    };
  };
};

export type PostRunsTriggerByPlanIdResponse =
  PostRunsTriggerByPlanIdResponses[keyof PostRunsTriggerByPlanIdResponses];
