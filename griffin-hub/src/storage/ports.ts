/**
 * Core storage abstractions (ports) for the application.
 * These interfaces define the contract that all storage adapters must implement.
 */

// =============================================================================
// Repository
// =============================================================================

/**
 * Query options for filtering, sorting, and pagination
 */
export interface QueryOptions<T> {
  filter?: Filter<T>;
  sort?: { field: keyof T; order: "asc" | "desc" };
  limit?: number;
  offset?: number;
}

/**
 * Type-safe filtering with basic operators
 */
export type Filter<T> = {
  [K in keyof T]?:
    | T[K]
    | {
        $in?: T[K][];
        $gt?: T[K];
        $gte?: T[K];
        $lt?: T[K];
        $lte?: T[K];
        $ne?: T[K];
      };
};

/**
 * Generic repository for CRUD operations on entities.
 * All entities must have an 'id' field.
 */
export interface Repository<T extends { id: string }> {
  /**
   * Create a new entity. The 'id' field should be generated by the implementation.
   */
  create(data: Omit<T, "id">): Promise<T>;

  /**
   * Find an entity by its ID. Returns null if not found.
   */
  findById(id: string): Promise<T | null>;

  /**
   * Find multiple entities with optional filtering, sorting, and pagination.
   */
  findMany(options?: QueryOptions<T>): Promise<T[]>;

  /**
   * Update an entity by ID. Returns the updated entity.
   * Throws if the entity doesn't exist.
   */
  update(id: string, data: Partial<Omit<T, "id">>): Promise<T>;

  /**
   * Delete an entity by ID.
   * Throws if the entity doesn't exist.
   */
  delete(id: string): Promise<void>;

  /**
   * Count entities matching the filter.
   */
  count(filter?: Filter<T>): Promise<number>;
}

// =============================================================================
// Job Queue
// =============================================================================

export enum JobStatus {
  PENDING = "pending",
  RUNNING = "running",
  COMPLETED = "completed",
  FAILED = "failed",
  RETRYING = "retrying",
}

export interface Job<T> {
  id: string;
  data: T;
  location: string;
  status: JobStatus;
  attempts: number;
  maxAttempts: number;
  priority: number;
  scheduledFor: Date;
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  error?: string;
}

export interface EnqueueOptions {
  /**
   * Location identifier for routing the job to specific agents.
   * Required for multi-location execution.
   */
  location: string;

  /**
   * When the job should be executed. Defaults to now.
   */
  runAt?: Date;

  /**
   * Priority (higher = more important). Defaults to 0.
   */
  priority?: number;

  /**
   * Maximum number of retry attempts. Defaults to 3.
   */
  maxAttempts?: number;
}

/**
 * Durable job queue for background task execution.
 */
export interface JobQueue<T = any> {
  /**
   * Add a job to the queue.
   * Returns the job ID.
   */
  enqueue(data: T, options: EnqueueOptions): Promise<string>;

  /**
   * Get the next job to process.
   * Returns null if no jobs are available.
   * Automatically marks the job as RUNNING.
   *
   * @param location - Optional location filter. If provided, only returns jobs for that location.
   */
  dequeue(location?: string): Promise<Job<T> | null>;

  /**
   * Mark a job as successfully completed.
   */
  acknowledge(jobId: string): Promise<void>;

  /**
   * Mark a job as failed.
   * If retry is true and attempts < maxAttempts, the job will be retried.
   */
  fail(jobId: string, error: Error, retry?: boolean): Promise<void>;

  /**
   * Get the current status of a job.
   */
  getStatus(jobId: string): Promise<JobStatus | null>;

  /**
   * Get a job by ID.
   */
  getJob(jobId: string): Promise<Job<T> | null>;
}

// =============================================================================
// Storage Backend
// =============================================================================

/**
 * Repository backend interface.
 * Provides access to data repositories with transaction support.
 */
export interface RepositoryBackend {
  /**
   * Get a repository for a specific collection/table.
   */
  repository<T extends { id: string }>(collection: string): Repository<T>;

  /**
   * Connect to the storage backend.
   * Should be called before using repositories.
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the storage backend.
   */
  disconnect(): Promise<void>;

  /**
   * Execute a function within a transaction.
   * If the function throws, the transaction is rolled back.
   * Optional: backends may throw "not implemented" if they don't support transactions.
   */
  transaction<R>(fn: (tx: RepositoryBackend) => Promise<R>): Promise<R>;

  /**
   * Execute a raw query for complex operations that don't fit the Repository pattern.
   * For memory backend: accepts a filter function that operates on collections.
   * For SQL backends: accepts SQL string with optional parameters.
   * Returns rows as plain objects of type T.
   */
  execute<T = unknown>(
    query: string | Function,
    params?: unknown[],
  ): Promise<T[]>;
}

/**
 * Job queue backend interface.
 * Provides access to background job queues.
 */
export interface JobQueueBackend {
  /**
   * Get a job queue for background task execution.
   * Optional name parameter allows for multiple named queues.
   */
  queue<T = any>(name?: string): JobQueue<T>;

  /**
   * Connect to the job queue backend.
   * Should be called before using queues.
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the job queue backend.
   */
  disconnect(): Promise<void>;
}

// =============================================================================
// Migrations
// =============================================================================

export interface Migration {
  version: string;
  name: string;
  up: (adapter: any) => Promise<void>;
  down: (adapter: any) => Promise<void>;
}

export interface MigrationRunner {
  /**
   * Run all pending migrations.
   */
  migrate(): Promise<void>;

  /**
   * Rollback the last N migrations.
   */
  rollback(count?: number): Promise<void>;

  /**
   * Get the current migration version.
   */
  version(): Promise<string | null>;

  /**
   * Get list of applied migrations.
   */
  applied(): Promise<string[]>;
}
